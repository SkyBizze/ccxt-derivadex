# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import math
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import OrderNotFound
from ccxt.base.decimal_to_precision import DECIMAL_PLACES
from ccxt.base.precise import Precise


class derivadex(Exchange):

    def describe(self):
        return self.deep_extend(super(derivadex, self).describe(), {
            'id': 'derivadex',
            'name': 'DerivaDEX',
            'countries': ['JP'],  # Japan
            'version': 'v1',
            'rateLimit': 200,  # TODO: add documentation for tiered rate limiting
            'pro': False,
            'has': {
                'CORS': None,
                'spot': False,
                'margin': False,
                'swap': True,
                'future': False,
                'option': False,
                'addMargin': False,
                'cancelAllOrders': True,
                'cancelOrder': True,
                'cancelOrders': False,
                'createOrder': True,
                'createReduceOnlyOrder': False,
                'editOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': False,
                'fetchDepositAddress': True,
                'fetchDepositAddresses': False,
                'fetchDepositAddressesByNetwork': False,
                'fetchFundingHistory': False,
                'fetchFundingRate': True,
                'fetchFundingRateHistory': False,
                'fetchFundingRates': True,
                'fetchIndexOHLCV': False,
                'fetchLedger': False,
                'fetchLeverage': False,
                'fetchLeverageTiers': False,
                'fetchMarketLeverageTiers': False,
                'fetchMarkets': True,
                'fetchMarkOHLCV': False,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenInterest': True,
                'fetchOpenOrders': False,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchPosition': False,
                'fetchPositions': True,
                'fetchPositionsRisk': False,
                'fetchPremiumIndexOHLCV': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
                'fetchTransactions': False,
                'fetchTransfer': False,
                'fetchTransfers': False,
                'reduceMargin': False,
                'setLeverage': True,
                'setMargin': False,
                'setMarginMode': False,
                'setPositionMode': False,
                'transfer': False,
                'withdraw': True,
            },
            'timeframes': {
                '1m': '1m',
                '1h': '1h',
                '1d': '1d',
            },
            'urls': {
                'test': {
                    'public': 'https://beta.derivadex.io',
                    'private': 'https://beta.derivadex.io',
                    'stats': 'https://beta.derivadex.io/stats',
                    'v2': 'http://op1.ddx.one:15080/v2',  # TODO: DELETE THIS
                    'op1': 'http://op1.ddx.one:15080/stats',  # TODO: del self before submitting
                    'raw': 'http://op1.ddx.one:15080',  # TODO: del self before submitting
                },
                'logo': 'https://gitlab.com/dexlabs/assets/-/raw/main/light-round.png',
                'api': {
                    'public': 'https://exchange.derivadex.com',
                    'private': 'https://exchange.derivadex.com',
                    'stats': 'https://exchange.derivadex.com/stats',
                    'v2': 'https://exchange.derivadex.com/v2',
                },
                'www': 'https://exchange.derivadex.com',
                'doc': [
                    'https://docs.derivadex.io',
                    'http://api.derivadex.io/',
                    'https://exchange.derivadex.com/api-docs',
                ],
            },
            'api': {
                'public': {
                    'get': {
                        'account/{trader}/strategy/{strategyId}/adls': 1,
                        'account/{trader}/strategy/{strategyId}/fills': 1,
                        'account/{trader}/strategy/{strategyId}/': 1,
                        'account/{trader}/strategy/{strategyId}/liquidations': 1,
                        'account/{trader}/strategy/{strategyId}/order_book': 1,
                        'account/{trader}/strategy/{strategyId}/order_intents': 1,
                        'account/{trader}/strategy/{strategyId}/positions': 1,
                        'account/{trader}/strategy/{strategyId}/strategy_updates': 1,
                        'account/{trader}': 1,
                        'account/{trader}/trader_updates': 1,
                        'adl': 1,
                        'ddx_fee_pool': 1,
                        'epochs': 1,
                        'fills': 1,
                        'insurance_fund': 1,
                        'liquidations': 1,
                        'order_book': 1,
                        'order_intents': 1,
                        'positions': 1,
                        'prices': 1,
                        'specs': 1,
                        'strategies': 1,
                        'startegy_updates': 1,
                        'trader_updates': 1,
                        'traders': 1,
                        'tx_logs': 1,
                        'aggregations/collateral': 1,
                        'aggregations/volume': 1,
                        'markets': 1,
                        'markets/order_book/L2': 1,
                        'markets/tickers': 1,
                        'snapshot/addresses': 1,
                    },
                },
                'v2': {
                    'get': {
                        'rest/ohlcv': 1,
                        'encryption-key': 1,
                    },
                    'post': {
                        'request': 1,
                    },
                },
                'raw': {
                    'get': {
                        'snapshot/addresses': 1,
                    },
                },
            },
            'requiredCredentials': {
                'walletAddress': True,
                'privateKey': True,
                'apiKey': False,
                'secret': False,
            },
            'precisionMode': DECIMAL_PLACES,
            'options': {
                'defaultType': 'swap',
                'defaultNetwork': 'ERC20',
                'networks': {
                    'ETH': 'ERC20',
                },
                'networksById': {
                    'ETH': 'ERC20',
                },
            },
            'fees': {
                'trading': {
                    'feeSide': 'get',
                    'tierBased': False,
                    'percentage': True,
                    'taker': 0.002,
                    'maker': 0.0,
                },
            },
            'encryptionKey': None,
        })

    def fetch_markets(self, params={}):
        """
        retrieves data on all markets for derivadex
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns [dict]: an array of objects representing market data
        """
        params['kind'] = 0
        response = self.publicGetSpecs(params)
        # {
        #     "value": [
        #         {
        #             "kind": 0,
        #             "name": "DDXPERP",
        #             "expr": "\n(Market :name "DDXPERP"\n :tick-size 0.1\n :max-order-notional 0\n :max-taker-price-deviation 0.02\n :min-order-size 0.0001\n)",
        #             "value": {
        #                 "tickSize": "0.1",
        #                 "minOrderSize": "0.0001",
        #                 "maxOrderNotional": "0",
        #                 "maxTakerPriceDeviation": "0.02"
        #             }
        #         },
        #         {
        #             "kind": 0,
        #             "name": "BTCPERP",
        #             "expr": "\n(Market :name "BTCPERP"\n :tick-size 1\n :max-order-notional 1000000\n :max-taker-price-deviation 0.02\n :min-order-size 0.00001\n)",
        #             "value": {
        #                 "tickSize": "1",
        #                 "minOrderSize": "0.00001",
        #                 "maxOrderNotional": "1000000",
        #                 "maxTakerPriceDeviation": "0.02"
        #             }
        #         },
        #         {
        #             "kind": 0,
        #             "name": "ETHPERP",
        #             "expr": "\n(Market :name "ETHPERP"\n :tick-size 0.1\n :max-order-notional 1000000\n :max-taker-price-deviation 0.02\n :min-order-size 0.0001\n)",
        #             "value": {
        #                 "tickSize": "0.1",
        #                 "minOrderSize": "0.0001",
        #                 "maxOrderNotional": "1000000",
        #                 "maxTakerPriceDeviation": "0.02"
        #             }
        #         }
        #     ],
        #         "timestamp": 1674260369,
        #         "success": True
        # }
        markets = response['value']
        return markets.filter((market) => market['name'] != 'DDXPERP').map((market) => {
            name = market['name']
            base = name[0:-4]
            return {
                'id': name,
                'symbol': name,
                'base': base,
                'quote': 'USD',
                'settle': 'USDC',
                'baseId': base.lower(),
                'quoteId': 'usd',
                'settleId': 'usdc',
                'type': 'swap',
                'spot': 'false',
                'margin': 'false',
                'swap': 'true',
                'future': 'false',
                'option': 'swap',
                'active': 'true',
                'contract': 'true',
                'linear': 'true',
                'inverse': 'false',
                'taker': '0.002',
                'maker': '0.000',
                'precision': {
                    'amount': 6,
                    'price': 6,
                    'quote': 6,
                },
                'limits': {
                    'leverage': {
                        'min': None,
                        'max': 3,
                    },
                    'amount': {
                        'min': market['value']['minOrderSize'],
                        'max': None,
                    },
                    'price': {
                        'min': market['value']['tickSize'],
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': market['value']['maxOrderNotional'],
                    },
                },
                'info': market,
            }
        })

    def fetch_currencies(self, params={}):
        """
        fetches all available currencies on an exchange
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns dict: an associative dictionary of currencies
        """
        networks = {}
        networks['ERC20'] = {
            'info': None,
            'id': 'ETH',
            'network': self.network_id_to_code('ETH'),
            'active': True,
            'deposit': True,
            'withdraw': True,
            'fee': None,
        }
        return [
            {
                'id': 'usdc',
                'code': 'USDC',
                'name': 'USDC',
                'active': True,
                'fee': 0,
                'precision': 6,
                'deposit': True,
                'withdraw': True,
                'limits': {
                    'deposit': {
                        'min': 1000,
                        'max': 1000000,
                    },
                },
                'networks': networks,
                'info': None,
            },
            {
                'id': 'ddx',
                'code': 'DDX',
                'name': 'DDX',
                'active': False,
                'fee': 0,
                'precision': 6,
                'deposit': True,
                'withdraw': True,
                'limits': {
                    'deposit': {
                        'min': 0.000001,
                        'max': None,
                    },
                },
                'networks': networks,
                'info': None,
            },
        ]

    def fetch_ticker(self, symbol, params={}):
        """
        fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        tickers = self.fetch_tickers([market['id']], params)
        ticker = self.safe_value(tickers, market['id'])
        if ticker is None:
            raise BadSymbol(self.id + ' fetchTicker() symbol ' + market['id'] + ' not found')
        return ticker

    def fetch_tickers(self, symbols=None, params={}):
        """
        fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        :param [str]|None symbols: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns dict: an array of `ticker structures <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        self.load_markets()
        symbols = symbols is list(self.markets) if None else self.market_symbols(symbols.keys())
        result = {}
        for i in range(0, len(symbols)):
            ticker = self.construct_ticker(symbols[i])
            if ticker is not None:
                result[symbols[i]] = ticker
        return result

    def construct_ticker(self, symbol):
        params = {}
        params['symbol'] = symbol
        params['depth'] = 1
            self.publicGetMarketsOrderBookL2(params),
            self.publicGetMarketsTickers({'symbol': symbol}),
        ])
        orderBookValue = orderBookResponse['value']
        bid = self.safe_string(orderBookValue[0], 'price')
        bidVolume = self.safe_string(orderBookValue[0], 'amount')
        ask = self.safe_string(orderBookValue[1], 'price')
        askVolume = self.safe_string(orderBookValue[1], 'amount')
        ticker = tickerResponse['value'][0]
        timestamp = self.safe_string(tickerResponse, 'timestamp')
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_string(ticker, 'high'),
            'low': self.safe_string(ticker, 'low'),
            'bid': bid,
            'bidVolume': bidVolume,
            'ask': ask,
            'askVolume': askVolume,
            'vwap': self.safe_string(ticker, 'volumeWeightedAveragePrice'),
            'open': self.safe_string(ticker, 'open'),
            'close': self.safe_string(ticker, 'close'),
            'last': self.safe_string(ticker, 'close'),
            'previousClose': None,
            'change': self.safe_string(ticker, 'change'),
            'percentage': self.safe_string(ticker, 'percentage'),
            'average': None,
            'baseVolume': self.safe_string(ticker, 'baseVolume'),
            'quoteVolume': self.safe_string(ticker, 'notionalVolume'),
            'info': {orderBookResponse, tickerResponse},
        }

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        """
        fetch all trades made by the user
        :param str|None symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch trades for
        :param int|None limit: the maximum number of trades structures to retrieve
        :param dict params: extra parameters specific to the derivadex api endpoint
        :param str|None params['order']: the chronological order of items in the response - 'asc' or 'desc'
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html#trade-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'trader': self.walletAddress,
            'strategy': 'main',
            'fillReason': '0',
        }
        if limit is not None:
            request['limit'] = limit  # default 500
        if since is not None:
            request['since'] = since / 1000
        request['order'] = params['order'] is not params['order'] if None else 'asc'
        extendedRequest = self.extend(request, params)
        if extendedRequest['trader'] is None:
            raise AuthenticationError(self.id + ' fetchMyTrades() walletAddress is None, set self.walletAddress or "address" in params')
        response = self.publicGetFills(extendedRequest)
        traderAddressWithDiscriminant = self.add_discriminant(self.walletAddress)
        mainStrategyIdHash = self.get_main_strategy_id_hash()
        return self.parse_trades_custom(response, market, since, limit, traderAddressWithDiscriminant, mainStrategyIdHash)

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        """
        get the list of most recent trades for a particular symbol
        :param str symbol: unified symbol of the market to fetch trades for
        :param int|None since: timestamp in ms of the earliest trade to fetch
        :param int|None limit: the maximum amount of trades to fetch
        :param dict params: extra parameters specific to the derivadex api endpoint
        :param str|None params['order']: the chronological order of items in the response - 'asc' or 'desc'
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html?#public-trades>`
        """
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'fillReason': '0',
        }
        if limit is not None:
            request['limit'] = limit  # default 500
        if since is not None:
            request['since'] = since / 1000
        request['order'] = params['order'] is not params['order'] if None else 'asc'
        response = self.publicGetFills(self.extend(request, params))
        # {
        #     value: [
        #       {
        #         epochId: '27',
        #         txOrdinal: '6',
        #         ordinal: '0',
        #         makerOrderHash: '0x87686e3ffa6b2e9c8a229a9b7fe948b504db94d376ce8e494f',
        #         amount: '0.05',
        #         symbol: 'BTCPERP',
        #         price: '22790',
        #         makerFee: '0',
        #         makerFeeSymbol: 'USDC',
        #         makerRealizedPnl: '0',
        #         takerOrderHash: '0x08fd0fd22dd23f3550d4edea3e37cceab4b9612116c14d71c0',
        #         takerFee: '2.279',
        #         takerFeeSymbol: 'USDC',
        #         takerRealizedPnl: '0',
        #         reason: '0',
        #         createdAt: '2023-01-25T20:13:12.574Z',
        #         liquidatedTrader: null,
        #         liquidatedStrategyIdHash: null
        #       },
        #       {
        #         epochId: '27',
        #         txOrdinal: '7',
        #         ordinal: '0',
        #         makerOrderHash: '0x87686e3ffa6b2e9c8a229a9b7fe948b504db94d376ce8e494f',
        #         amount: '0.01',
        #         symbol: 'BTCPERP',
        #         price: '22790',
        #         makerFee: '0',
        #         makerFeeSymbol: 'USDC',
        #         makerRealizedPnl: '0',
        #         takerOrderHash: '0x80b89184c49b710455ec17948785a07f4bb357561490a3e683',
        #         takerFee: '0.4558',
        #         takerFeeSymbol: 'USDC',
        #         takerRealizedPnl: '0',
        #         reason: '0',
        #         createdAt: '2023-01-25T20:13:18.578Z',
        #         liquidatedTrader: null,
        #         liquidatedStrategyIdHash: null
        #       },
        #     ]
        # }
        return self.parse_trades_custom(response, market, since, limit)

    def get_order_intents(self, trades):
        result = {}
        params = {
            'orderHash': [],
        }
        for i in range(0, len(trades)):
            params['orderHash'].append(trades[i]['takerOrderHash'])
        orderIntentResponse = self.publicGetOrderIntents(params)
        orderIntentResponseValue = orderIntentResponse['value']
        for i in range(0, len(orderIntentResponseValue)):
            result[orderIntentResponseValue[i]['orderHash']] = orderIntentResponseValue[i]
        return result

    def parse_trades_custom(self, trades, market=None, since=None, limit=None, trader=None, strategy=None):
        trades = self.to_array(trades)
        result = []
        orderIntents = self.get_order_intents(trades[0])
        for i in range(0, len(trades[0])):
            trade = self.parse_trade_custom(trades[0][i], orderIntents, trader, strategy)
            result.append(trade)
        result = self.sort_by_2(result, 'timestamp', 'id')
        symbol = market['symbol'] if (market is not None) else None
        tail = (since is None)
        return self.filter_by_symbol_since_limit(result, symbol, since, limit, tail)

    def parse_trade_custom(self, trade, orderIntents, trader=None, strategy=None):
        id = self.safe_string(trade, 'takerOrderHash') + '_' + self.safe_string(trade, 'epochId') + '_' + self.safe_string(trade, 'txOrdinal')
        timestamp = self.parse8601(self.safe_string(trade, 'createdAt'))
        datetime = self.iso8601(timestamp)
        symbol = self.safe_string(trade, 'symbol')
        order = self.safe_string(trade, 'takerOrderHash')
        price = self.safe_string(trade, 'price')
        amount = self.safe_string(trade, 'amount')
        fee = {
            'cost': self.safe_string(trade, 'takerFee'),
            'currency': self.safe_string(trade, 'takerFeeSymbol'),
        }
        takerOrderHash = self.safe_string(trade, 'takerOrderHash')
        sideNumber = self.safe_integer(orderIntents[takerOrderHash], 'side')
        orderTypeNumber = self.safe_integer(orderIntents[takerOrderHash], 'orderType')
        side = sideNumber == 'buy' if 0 else 'sell'
        orderType = self.get_order_type(orderTypeNumber)
        # liquidations have null takerOrderHash
        takerOrMaker = takerOrderHash != 'taker' if None else None
        if trader is not None and strategy is not None and self.safe_string(trade, 'makerOrderTrader') == trader.lower() and self.safe_string(trade, 'makerOrderStrategyIdHash') == strategy:
            takerOrMaker = 'maker'
        return self.safe_trade({
            'info': trade,
            'timestamp': timestamp,
            'datetime': datetime,
            'symbol': symbol,
            'id': id,
            'order': order,
            'type': orderType,
            'takerOrMaker': takerOrMaker,
            'side': side,
            'price': price,
            'cost': None,
            'amount': amount,
            'fee': fee,
        })

    def parse_trade(self, trade, market=None):
        id = self.safe_string(trade, 'takerOrderHash') + '_' + self.safe_string(trade, 'epochId') + '_' + self.safe_string(trade, 'txOrdinal')
        timestamp = self.parse8601(self.safe_string(trade, 'createdAt'))
        datetime = self.iso8601(timestamp)
        symbol = self.safe_string(trade, 'symbol')
        order = self.safe_string(trade, 'takerOrderHash')
        price = self.safe_string(trade, 'price')
        amount = self.safe_string(trade, 'amount')
        fee = {
            'cost': self.safe_string(trade, 'takerFee'),
            'currency': self.safe_string(trade, 'takerFeeSymbol'),
        }
        takerOrderHash = self.safe_string(trade, 'takerOrderHash')
        # liquidations have null takerOrderHash
        takerOrMaker = takerOrderHash != 'taker' if None else None
        return self.safe_trade({
            'info': trade,
            'timestamp': timestamp,
            'datetime': datetime,
            'symbol': symbol,
            'id': id,
            'order': order,
            'type': None,
            'takerOrMaker': takerOrMaker,
            'side': None,
            'price': price,
            'cost': None,
            'amount': amount,
            'fee': fee,
        })

    def fetch_order_book(self, symbol, limit=None, params={}):
        """
        fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int|None limit: the maximum amount of order book entries to return
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/en/latest/manual.html#order-book-structure>` indexed by market symbols
        """
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['depth'] = limit
        response = self.publicGetOrderBook(self.extend(request, params))
        # value: [
        #     {
        #       traderAddress: '0x004404ac8bd8f9618d27ad2f1485aa1b2cfd82482d',
        #       strategyId: 'main',
        #       orderHash: '0x2e401956ae605a3a222bd92533260103a23a963e6e55b066a0',
        #       symbol: 'BTCPERP',
        #       amount: '0.035',
        #       price: '23000',
        #       side: '0',
        #       originalAmount: '0.04',
        #       bookOrdinal: '0'
        #     },
        #     {
        #       traderAddress: '0x004404ac8bd8f9618d27ad2f1485aa1b2cfd82482d',
        #       strategyId: 'main',
        #       orderHash: '0x746be891d408f6e415760241c86d9c852a17514d59299a78de',
        #       symbol: 'BTCPERP',
        #       amount: '0.08',
        #       price: '24000',
        #       side: '1',
        #       originalAmount: '0.08',
        #       bookOrdinal: '1'
        #     }
        #   ]
        responseValue = response['value']
        timestamp = self.safe_number(response, 'timestamp') * 1000
        result = {
            'symbol': market['id'],
            'bids': [],
            'asks': [],
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'nonce': None,
        }
        for i in range(0, len(responseValue)):
            order = responseValue[i]
            side = 'bids' if (order['side'] == '0') else 'asks'
            amount = self.safe_number(order, 'amount')
            price = self.safe_number(order, 'price')
            result[side].append([price, amount])
        result['bids'].reverse()
        return result

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        """
        fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        :param str symbol: unified symbol of the market to fetch OHLCV data for
        :param str timeframe: the length of time each candle represents
        :param int|None since: timestamp in ms of the earliest candle to fetch
        :param int|None limit: the maximum amount of candles to fetch
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns [[int]]: A list of candles ordered as timestamp, open, high, low, close, volume
        """
        self.load_markets()
        market = self.market(symbol)
        fromTimestamp = self.get_time_for_ohlcv_request(self.timeframes[timeframe], since, limit)
        request = {
            'symbol': market['id'],
            'interval': self.timeframes[timeframe],
            'from': fromTimestamp / 1000,
        }
        if limit is not None:
            request['to'] = self.get_to_param_for_ohlcv_request(self.timeframes[timeframe], fromTimestamp, limit) / 1000
        if since is not None:
            request['since'] = since
        response = self.v2GetRestOhlcv(self.extend(request, params))
        return self.parse_ohlcvs(response['ohlcv'], market, timeframe, since, limit)

    def parse_ohlcv(self, ohlcv, market=None):
        timestamp = self.safe_integer(ohlcv, 'timestamp')
        open = self.safe_number(ohlcv, 'open')
        high = self.safe_number(ohlcv, 'high')
        low = self.safe_number(ohlcv, 'low')
        close = self.safe_number(ohlcv, 'close')
        volume = self.safe_number(ohlcv, 'volume')
        return [timestamp, open, high, low, close, volume]

    def get_time_for_ohlcv_request(self, interval, time, limit):
        msInMinute = 60 * 1000
        msInHour = 60 * 1000 * 60
        msInDay = 60 * 1000 * 60 * 24
        if time is None:
            duration = self.parse_timeframe(interval)
            time = self.milliseconds() - duration * limit * 1000 - 1000
        if interval == '1m':
            return int(math.ceil(time / msInMinute)) * msInMinute
        if interval == '1h':
            return int(math.ceil(time / msInHour)) * msInHour
        if interval == '1d':
            return int(math.ceil(time / msInDay)) * msInDay

    def get_to_param_for_ohlcv_request(self, interval, from, limit):
        msInMinute = 60 * 1000
        msInHour = 60 * 1000 * 60
        msInDay = 60 * 1000 * 60 * 24
        if interval == '1m':
            return from + (msInMinute * limit)
        if interval == '1h':
            return from + (msInHour * limit)
        if interval == '1d':
            return from + (msInDay * limit)

    def wait(self, ms):
        # eslint-disable-next-line no-promise-executor-return
        new Promise((resolve) => setTimeout(resolve, ms))

    def get_sequenced_order(self, operatorResponse, lookbackLimit=None):
        """
        fetches information on an order made by the user
        :param dict operatorResponse: the operator response object associated with a derivadex createOrder() request
        :param int|None lookbackLimit: the maximum number of order intents to lookback through to find an order intent. You may need a higher lookbackLimit value if many orders have been placed since the operatorResponse you are searching for returned
        :returns dict: An `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        params = {
            'trader': self.walletAddress,
            'strategyId': 'main',
            'order': 'desc',
        }
        if lookbackLimit is not None:
            params['limit'] = lookbackLimit
        response = self.publicGetAccountTraderStrategyStrategyIdOrderIntents(params)
        order = response['value'].find((intent) => intent.nonce == operatorResponse.c.nonce)
        if order is None:
            self.wait(1000)  # retry after 1 second
            response = self.publicGetAccountTraderStrategyStrategyIdOrderIntents(params)
            order = response['value'].find((intent) => intent.nonce == operatorResponse.c.nonce)
            if order is None:
                raise OrderNotFound(self.id + ' getSequencedOrder() could not find the order intent associated with self operator response')
        return self.parse_order(order)

    def fetch_public_orders(self, symbol=None, since=None, limit=None, params={}):
        """
        fetches information on multiple public orders made in a market
        :param str|None symbol: unified market symbol of the market orders were made in
        :param int|None since: the earliest time in ms to fetch orders for
        :param int|None limit: the maximum number of  orde structures to retrieve
        :param str|None params['order']: the chronological order of items in the response - 'asc' or 'desc'
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        if since is not None:
            request['since'] = since / 1000
        request['order'] = params['order'] is not params['order'] if None else 'asc'
        response = self.publicGetOrderIntents(request)
        return self.parse_orders_custom(response['value'], market, since, limit)

    def fetch_order(self, id, symbol=None, params={}):
        """
        fetches information on an order made by the user
        :param str|None symbol: unified symbol of the market the order was made in
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrders() requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'orderHash': [id],
        }
        response = self.publicGetOrderIntents(request)
        return self.parse_order(response['value'][0], market)

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        """
        fetches information on multiple orders made by the user
        :param str|None symbol: unified market symbol of the market orders were made in
        :param int|None since: the earliest time in ms to fetch orders for
        :param int|None limit: the maximum number of order structures to retrieve
        :param str|None params['order']: the chronological order of items in the response - 'asc' or 'desc'
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'trader': self.walletAddress,
            'strategyId': 'main',
        }
        if limit is not None:
            request['limit'] = limit
        if since is not None:
            request['since'] = since / 1000
        request['order'] = params['order'] is not params['order'] if None else 'asc'
        response = self.publicGetAccountTraderStrategyStrategyIdOrderIntents(request)
        return self.parse_orders_custom(response['value'], market, since, limit)

    def parse_orders_custom(self, orders, market=None, since=None, limit=None, params={}):
        results = []
        if isinstance(orders, list):
            for i in range(0, len(orders)):
                order = self.extend(await self.parse_order(orders[i], market), params)
                results.append(order)
        else:
            ids = list(orders.keys())
            for i in range(0, len(ids)):
                id = ids[i]
                order = self.extend(self.parse_order(self.extend({'id': id}, orders[id]), market), params)
                results.append(order)
        results = self.sort_by(results, 'timestamp')
        symbol = market['symbol'] if (market is not None) else None
        tail = since is None
        return self.filter_by_symbol_since_limit(results, symbol, since, limit, tail)

    def parse_order(self, order, market=None):
        # {
        #     "epochId":"1",
        #     "txOrdinal":"7",
        #     "orderHash":"0x2e401956ae605a3a222bd92533260103a23a963e6e55b066a0",
        #     "symbol":"BTCPERP",
        #     "amount":"0.04",
        #     "price":"23000",
        #     "side":0,
        #     "orderType":0,
        #     "stopPrice":"0",
        #     "nonce":"0x00000000000000000000000000000000000000000000000000000185f46343ae",
        #     "signature":"0xe5de522ee59134005016dd9e1f59b625052551c2f722261c3a31060c792384ba0152361624013a46685adf163335e4cc8006bfedfadb3896c2f5910d1391fc131b",
        #     "createdAt":"2023-01-27T18:00:26.960Z",
        #     "traderAddress":"0x004404ac8bd8f9618d27ad2f1485aa1b2cfd82482d",
        #     "strategyId":"main"
        # }
        id = self.safe_string(order, 'orderHash')
        datetime = self.safe_string(order, 'createdAt')
        timestamp = self.parse8601(datetime)
        symbol = self.safe_string(order, 'symbol')
        orderHash = self.safe_string(order, 'orderHash')
        sideNumber = self.safe_integer(order, 'side')
        orderTypeNumber = self.safe_integer(order, 'orderType')
        side = sideNumber == 'buy' if 0 else 'sell'
        price = self.safe_string(order, 'price')
        amount = self.safe_string(order, 'amount')
        params = {
            'orderHash': [orderHash],
            'fillReason': [0, 1, 2],
        }
        fillResponse = self.publicGetFills(params)
        fills = fillResponse['value']
        status, filled = self.get_order_status_and_filled_amount(fills, amount)
        orderType = self.get_order_type(orderTypeNumber)
        return self.safe_order({
            'id': id,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': symbol,
            'type': orderType,
            'timeInForce': 'GTC',
            'side': side,
            'price': price,
            'average': None,
            'amount': amount,
            'filled': filled,
            'remaining': self.parse_number(amount) - filled,
            'cost': None,
            'trades': None,
            'fee': None,
            'info': {order, fills},
        }, market)

    def get_order_status_and_filled_amount(self, fills, orderAmount):
        filledAmount = 0
        isCancel = False
        for i in range(0, len(fills)):
            if fills[i]['reason'] == '2':
                isCancel = True
            else:
                filledAmount += self.parse_number(fills[i]['amount'])
        if filledAmount == self.parse_number(orderAmount):
            return ['closed', filledAmount]
        if isCancel:
            return ['canceled', filledAmount]
        return ['open', filledAmount]

    def get_order_type(self, orderTypeNumber):
        if orderTypeNumber == 0:
            return 'limit'
        elif orderTypeNumber == 1:
            return 'market'
        elif orderTypeNumber == 2:
            return 'stop'

    def order_type_to_int(self, orderTypeString):
        if orderTypeString == 'Limit':
            return 0
        elif orderTypeString == 'Market':
            return 1
        else:
            return 2

    def order_side_to_int(self, orderSide):
        if orderSide == 'Bid':
            return 0
        else:
            return 1

    def update_profile(self, payFeesInDDX):
        """
        update a trader profile
        :param bool payFeesInDDX: whether to pay trading fees in DDX or not.
        :returns bool: whether the trader profile was updated successfully
        """
        isAuthenticated = self.check_required_credentials()
        if not isAuthenticated:
            raise AuthenticationError(self.id + ' updateProfile endpoint requires privateKey and walletAddress credentials')
        orderIntent = self.get_operator_profile_update_intent(payFeesInDDX)
        operatorResponse = self.get_operator_response_for_order_intent(orderIntent, 'ProfileUpdate')
        if operatorResponse['t'] != 'Sequenced':
            raise ExchangeError(self.id + `updateProfile request failed with error ${operatorResponse['t']}, error contents: ${self.json(operatorResponse['c'])}`)
        return True

    def cancel_all_orders(self, symbol=None, params={}):
        """
        cancel all open orders
        :param str|None symbol: unified market symbol, only orders in the market of self symbol are cancelled when symbol is not None
        :param dict params: extra parameters specific to the derivadex api endpoint
        :param str|None params['strategyId']: the trader strategyId for which to cancel all orders
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        isAuthenticated = self.check_required_credentials()
        if not isAuthenticated:
            raise AuthenticationError(self.id + ' cancelAllOrders endpoint requires privateKey and walletAddress credentials')
        strategy = params['strategyId'] is 'main' if None else params['strategyId']
        orderIntent = self.get_operator_cancel_all_orders_intent(strategy)
        operatorResponse = self.get_operator_response_for_order_intent(orderIntent, 'CancelAll')
        if operatorResponse['t'] != 'Sequenced':
            raise ExchangeError(self.id + `cancelAllOrders request failed with error ${operatorResponse['t']}, error contents: ${self.json(operatorResponse['c'])}`)
        return operatorResponse

    def cancel_order(self, id, symbol=None, params={}):
        """
        cancels an open order
        :param str id: order id
        :param str|None symbol: not used by derivadex cancelOrder()
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns dict: An `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        isAuthenticated = self.check_required_credentials()
        if not isAuthenticated:
            raise AuthenticationError(self.id + ' cancelOrder endpoint requires privateKey and walletAddress credentials')
        self.load_markets()
        market = self.market(symbol)
        orderIntent = self.get_operator_cancel_order_intent(market['id'], id)
        operatorResponse = self.get_operator_response_for_order_intent(orderIntent, 'CancelOrder')
        timestamp = Date.now()
        if operatorResponse['t'] != 'Sequenced':
            raise ExchangeError(self.id + `cancelOrder request failed with error ${operatorResponse['t']}, error contents: ${self.json(operatorResponse['c'])}`)
        return self.safe_order({
            'id': None,
            'clientOrderId': None,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': None,
            'symbol': market['id'],
            'type': None,
            'timeInForce': 'GTC',
            'side': None,
            'price': None,
            'average': None,
            'amount': None,
            'filled': None,
            'remaining': None,
            'cost': None,
            'trades': None,
            'fee': None,
            'info': operatorResponse,
        }, market)

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        """
        create a trade order
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float|None price: the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        :param dict params: extra parameters specific to the derivadex api endpoint
        :param bool|None params['getOrderConfirmation']:  # if set to True, createOrder will return an order structure, otherwise createOrder will return the raw operator response.
        :returns dict: an `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        isAuthenticated = self.check_required_credentials()
        if not isAuthenticated:
            raise AuthenticationError(self.id + ' createOrder endpoint requires privateKey and walletAddress credentials')
        self.load_markets()
        market = self.market(symbol)
        orderType = self.capitalize(type)
        orderIntent = self.get_operator_submit_order_intent(market['id'], side, orderType, amount, price)
        operatorResponse = self.get_operator_response_for_order_intent(orderIntent, 'Order')
        if operatorResponse['t'] != 'Sequenced':
            raise ExchangeError(self.id + ` createOrder request failed with error ${self.json(operatorResponse['t'])}, error contents: ${self.json(operatorResponse['c'])}`)
        if not params.getOrderConfirmation:
            return operatorResponse
        return self.get_sequenced_order(operatorResponse, 10)

    def get_operator_response_for_order_intent(self, orderIntent, requestType):
        scaledOrderIntent = requestType == self.get_scaled_order_intent(orderIntent) if 'Order' else orderIntent
        encryptionKey = self.encryptionKey
        if encryptionKey is None:
            encryptionKey = self.v2GetEncryptionKey()
            self.encryptionKey = encryptionKey
        # addressesResponse = self.rawGetSnapshotAddresses({'contractDeployment': 'beta'})  # TODO: switch to mainnet deployment
        orderIntentData = self.get_order_intent_typed_data(
            scaledOrderIntent,
            # addressesResponse['chainId'],
            100,  # TODO: use mainnet chainId
            # addressesResponse['addresses']['derivaDEXAddress']
            '0x48bacb9266a570d521063ef5dd96e61686dbe788',  # TODO: use mainnet derivaDEXAddress
            requestType
        )
        # typedData = self.transform_typed_data_for_ethers(orderIntentData)
        signature = self.sign_typed_data(Buffer.from(self.privateKey, 'hex'), {'data': orderIntentData})
        orderIntent['signature'] = signature
        if requestType == 'Order':
            orderIntent['amount'] = str(orderIntent['amount'])
            orderIntent['price'] = str(orderIntent['price'])
            orderIntent['stopPrice'] = str(orderIntent['stopPrice'])
        intent = {'t': requestType, 'c': orderIntent}
        encryptedIntent = self.encrypt_intent(encryptionKey, intent)
        buffer = Buffer.from(encryptedIntent.replace(/^0x/, ''), 'hex')
        return self.v2PostRequest(buffer)

    def add_discriminant(self, traderAddress):
        # TODO: look up / resolve discriminant from chainId -- hard coding 00 for ethereum for now
        prefix = '0x00'
        return `${prefix}${traderAddress[2:]}`

    def as_nonce(self, num):
        return `0x${num.toString(16).rjust(64, '0')}`

    def get_operator_submit_order_intent(self, symbol, side, orderType, amount, price):
        return {
            'traderAddress': self.walletAddress,
            'symbol': symbol,
            'strategy': 'main',
            'side': side == 'Bid' if 'buy' else 'Ask',
            'orderType': orderType,
            'nonce': self.as_nonce(Date.now()),
            'amount': new Precise str((amount)),
            'price': price is new Precise('0') if None else new Precise str((price)),
            'stopPrice': new Precise('0'),
            'signature': '0x0',
        }

    def get_operator_cancel_order_intent(self, symbol, orderHash):
        ZERO_PADDING = '00000000000000'
        return {
            'symbol': symbol,
            'nonce': self.as_nonce(Date.now()),
            'signature': '0x',
            'orderHash': orderHash + ZERO_PADDING,
        }

    def get_operator_cancel_all_orders_intent(self, strategyId):
        return {
            'strategyId': strategyId,
            'nonce': self.as_nonce(Date.now()),
            'signature': '0x',
        }

    def get_operator_profile_update_intent(self, payFeesInDDX):
        return {
            'payFeesInDdx': payFeesInDDX,
            'nonce': self.as_nonce(Date.now()),
            'signature': '0x',
        }

    def get_scaled_order_intent(self, intent):
        operatorDecimals = 6
        operatorDecimalMultiplier = Precise((10 ** str(operatorDecimals)))
        return {
            'traderAddress': intent['traderAddress'],
            'symbol': intent['symbol'],
            'strategy': intent['strategy'],
            'side': intent['side'],
            'orderType': intent['orderType'],
            'nonce': intent['nonce'],
            'amount': intent['amount'].mul(operatorDecimalMultiplier),
            'price': intent['price'].mul(operatorDecimalMultiplier),
            'stopPrice': intent['stopPrice'].mul(operatorDecimalMultiplier),
            'signature': intent['signature'],
        }

    def transform_typed_data_for_ethers(self, typedData):
        return {
            'domain': typedData.domain,
            'types': self.omit(typedData.types, 'EIP712Domain'),
            'value': typedData.message,
        }

    def encode_string_into_bytes32(self, str):
        encoder = TextEncoder()
        encodedStr = encoder.encode(str)
        lengthHex = len(encodedStr).toString(16)
        paddedLengthHex = lengthHex.rjust(2, '0')
        bytes32Str = '0x' + paddedLengthHex + Buffer.from(encodedStr).toString('hex').ljust(62, '0')
        return bytes32Str

    def get_order_intent_typed_data(self, orderIntent, chainId, verifyingContractAddress, requestType):
        if requestType == 'Order':
            return self.create_order_intent_typed_data(orderIntent, chainId, verifyingContractAddress)
        if requestType == 'CancelOrder':
            return self.cancel_order_intent_typed_data(orderIntent, chainId, verifyingContractAddress)
        if requestType == 'CancelAll':
            return self.cancel_all_orders_intent_typed_data(orderIntent, chainId, verifyingContractAddress)
        if requestType == 'ProfileUpdate':
            return self.profile_update_intent_typed_data(orderIntent, chainId, verifyingContractAddress)

    def create_order_intent_typed_data(self, orderIntent, chainId, verifyingContractAddress):
        return {
            'primaryType': 'OrderParams',
            'types': {
                'EIP712Domain': [
                    {'name': 'name', 'type': 'string'},
                    {'name': 'version', 'type': 'string'},
                    {'name': 'chainId', 'type': 'uint256'},
                    {'name': 'verifyingContract', 'type': 'address'},
                ],
                'OrderParams': [
                    {'name': 'symbol', 'type': 'bytes32'},
                    {'name': 'strategy', 'type': 'bytes32'},
                    {'name': 'side', 'type': 'uint256'},
                    {'name': 'orderType', 'type': 'uint256'},
                    {'name': 'nonce', 'type': 'bytes32'},
                    {'name': 'amount', 'type': 'uint256'},
                    {'name': 'price', 'type': 'uint256'},
                    {'name': 'stopPrice', 'type': 'uint256'},
                ],
            },
            'domain': self.create_eip712_domain_seperator(chainId, verifyingContractAddress),
            'message': {
                'symbol': self.encode_string_into_bytes32(orderIntent.symbol),
                'strategy': self.encode_string_into_bytes32(orderIntent.strategy),
                'side': self.order_side_to_int str((orderIntent.side)),
                'orderType': self.order_type_to_int str((orderIntent.orderType)),
                'nonce': orderIntent.nonce,
                'amount': str(orderIntent.amount),
                'price': str(orderIntent.price),
                'stopPrice': str(orderIntent.stopPrice),
            },
        }

    def cancel_order_intent_typed_data(self, cancelIntent, chainId, verifyingContractAddress):
        return {
            'primaryType': 'CancelOrderParams',
            'types': {
                'EIP712Domain': [
                    {'name': 'name', 'type': 'string'},
                    {'name': 'version', 'type': 'string'},
                    {'name': 'chainId', 'type': 'uint256'},
                    {'name': 'verifyingContract', 'type': 'address'},
                ],
                'CancelOrderParams': [
                    {'name': 'symbol', 'type': 'bytes32'},
                    {'name': 'orderHash', 'type': 'bytes32'},
                    {'name': 'nonce', 'type': 'bytes32'},
                ],
            },
            'domain': self.create_eip712_domain_seperator(chainId, verifyingContractAddress),
            'message': {
                'symbol': self.encode_string_into_bytes32(cancelIntent.symbol),
                'orderHash': cancelIntent.orderHash,
                'nonce': cancelIntent.nonce,
            },
        }

    def cancel_all_orders_intent_typed_data(self, cancelAllIntent, chainId, verifyingContractAddress):
        return {
            'primaryType': 'CancelAllParams',
            'types': {
                'EIP712Domain': [
                    {'name': 'name', 'type': 'string'},
                    {'name': 'version', 'type': 'string'},
                    {'name': 'chainId', 'type': 'uint256'},
                    {'name': 'verifyingContract', 'type': 'address'},
                ],
                'CancelAllParams': [
                    {'name': 'strategy', 'type': 'bytes32'},
                    {'name': 'nonce', 'type': 'bytes32'},
                ],
            },
            'domain': self.create_eip712_domain_seperator(chainId, verifyingContractAddress),
            'message': {
                'strategy': self.encode_string_into_bytes32(cancelAllIntent.strategyId),
                'nonce': cancelAllIntent.nonce,
            },
        }

    def profile_update_intent_typed_data(self, updateProfileIntent, chainId, verifyingContractAddress):
        return {
            'primaryType': 'UpdateProfileParams',
            'types': {
                'EIP712Domain': [
                    {'name': 'name', 'type': 'string'},
                    {'name': 'version', 'type': 'string'},
                    {'name': 'chainId', 'type': 'uint256'},
                    {'name': 'verifyingContract', 'type': 'address'},
                ],
                'UpdateProfileParams': [
                    {'name': 'payFeesInDdx', 'type': 'bool'},
                    {'name': 'nonce', 'type': 'bytes32'},
                ],
            },
            'domain': self.create_eip712_domain_seperator(chainId, verifyingContractAddress),
            'message': {
                'payFeesInDdx': updateProfileIntent.payFeesInDdx,
                'nonce': updateProfileIntent.nonce,
            },
        }

    def create_eip712_domain_seperator(self, chainId, verifyingContractAddress):
        return {
            'name': 'DerivaDEX',
            'version': '1',
            'chainId': chainId,
            'verifyingContract': verifyingContractAddress,
        }

    def encrypt_intent(self, encryptionKey, payload):
        # Create an ephemeral ECDSA private key to encrypt the request.
        secretKeyBytes = self.word_array_to_bytes(CryptoJS.lib.WordArray.random(32), 32)
        # Unique single-use nonce for each encryption.
        nonceBytes = self.word_array_to_bytes(CryptoJS.lib.WordArray.random(12), 12)
        json = json.dumps(payload)
        buffer = Buffer.from(json)
        requestBytes = Uint8Array(buffer)
        encryptionKeyBuffer = Buffer.from(encryptionKey[3:], 'hex')
        encryptionKeyBytes = Uint8Array(encryptionKeyBuffer)
        encryptedBytes = self.encrypt(requestBytes, secretKeyBytes, encryptionKeyBytes, nonceBytes)
        return self.hexlify(encryptedBytes)

    def hexlify(self, bytes):
        hexCharacters = '0123456789abcdef'
        result = '0x'
        for i in range(0, len(bytes)):
            v = bytes[i]
            # eslint-disable-next-line no-bitwise
            result += hexCharacters[(v & 0xf0) >> 4] + hexCharacters[v & 0x0f]
        return result

    def word_array_to_bytes(self, wordArray, size):
        bytes = Uint8Array(size)
        truncatedWords = wordArray.words[0:size / 4]
        for i in range(0, size):
            # eslint-disable-next-line no-bitwise
            byte = (truncatedWords[i >>> 2] >>>(24 - (i % 4) * 8)) & 0xff
            bytes[i] = byte
        return bytes

    def encrypt(self, str, secretKey, encryptionKeyBytes, nonceBytes):
        EC = elliptic.ec
        # Create a secp256k1 curve object
        secp256k1 = EC('secp256k1')
        # Uint8Array-encoded network public key
        networkPublicKey = secp256k1.keyFromPublic(encryptionKeyBytes).getPublic()
        # Create a PrivateKey object from the secret key
        myPrivateKey = secp256k1.keyFromPrivate(secretKey)
        # Get the corresponding public key
        myPublicKey = myPrivateKey.getPublic()
        compressedPublicKeyBytes = myPublicKey.encodeCompressed()
        # Compute the shared public key
        sharedPublicKey = networkPublicKey.mul(myPrivateKey.priv)
        keccak256 = CryptoJS.algo.SHA3.create({'outputLength': 256})
        sharedPublicKeyCompressed = sharedPublicKey.encodeCompressed()
        sharedPublicKeyCompressedBytes = Uint8Array(sharedPublicKeyCompressed)
        keccak256.update(CryptoJS.lib.WordArray.create(sharedPublicKeyCompressedBytes))
        hash = keccak256.finalize()
        derivedKey = self.word_array_to_bytes(hash, 16)
        # the provided CryptoJS static dependency does not include aes gcm encryption mode
        # so we have to use the node crypto library for now
        cipher = self.create_cipheriv('aes-128-gcm', derivedKey, nonceBytes)
        encodedMessage = Buffer.from(str, 'utf8')
        messageLength = Buffer.alloc(4)
        messageLength.writeUInt32BE(len(encodedMessage), 0)
        dataToEncrypt = Buffer.concat([messageLength, encodedMessage])
        cipherText = cipher.update(dataToEncrypt, 'utf8', 'base64')
        cipherText += cipher.final('base64')
        authTag = cipher.getAuthTag().toString('base64')
        cipherBytes = Uint8Array(Buffer.from(cipherText, 'base64'))
        tagBytes = Uint8Array(Buffer.from(authTag, 'base64'))
        totalLength = len(cipherBytes) + len(tagBytes) + len(nonceBytes) + len(compressedPublicKeyBytes)
        concatenatedUint8Array = Uint8Array(totalLength)
        offset = 0
        concatenatedUint8Array.set(cipherBytes, offset)
        offset += len(cipherBytes)
        concatenatedUint8Array.set(tagBytes, offset)
        offset += len(tagBytes)
        concatenatedUint8Array.set(nonceBytes, offset)
        offset += len(nonceBytes)
        concatenatedUint8Array.set(compressedPublicKeyBytes, offset)
        return concatenatedUint8Array

    def fetch_balance(self, params={}):
        """
        query for balance and get the amount of funds available for trading or funds locked in orders
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/en/latest/manual.html?#balance-structure>`
        """
        strategyRequest = {
            'trader': self.walletAddress,
            'strategyId': 'main',
        }
        strategyResponse = self.publicGetAccountTraderStrategyStrategyId(strategyRequest)
        # {
        #     value: {
        #       trader: '0x0006cef8e666768cc40cc78cf93d9611019ddcb628',
        #       strategyId: 'main',
        #       strategyIdHash: '0x2576ebd1',
        #       maxLeverage: '3',
        #       freeCollateral: '9958.802449',
        #       frozenCollateral: '1000000',
        #       frozen: False
        #     },
        #     timestamp: '1677267890',
        #     success: True
        # }
        return self.parse_balance(strategyResponse['value'])

    def parse_balance(self, strategy):
        result = {
            'info': strategy,
        }
        account = self.account()
        total = self.safe_number(strategy, 'freeCollateral') + self.safe_number(strategy, 'frozenCollateral')
        account['total'] = str(total)
        account['free'] = self.safe_string(strategy, 'freeCollateral')
        result['USDC'] = account
        return self.safe_balance(result)

    def get_main_strategy_id_hash(self):
        return '0x2576ebd1'

    def fetch_deposit_address(self, code, params={}):
        """
        fetch the deposit address for a currency associated with self account
        :param str code: unified currency code
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns dict: an `address structure <https://docs.ccxt.com/en/latest/manual.html#address-structure>`
        """
        addresses = self.rawGetSnapshotAddresses({'contractDeployment': 'beta'})  # TODO: switch to mainnet
        if code != 'USDC' and code != 'DDX':
            raise BadSymbol(self.id + ' fetchDepositAddress() does not support ' + code)
        return addresses['addresses']['derivaDEXAddress']

    def fetch_positions(self, symbols=None, params={}):
        """
        fetch all open positions
        :param [str]|None symbols: list of unified market symbols
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns [dict]: a list of `position structure <https://docs.ccxt.com/en/latest/manual.html#position-structure>`
        """
        response = self.publicGetPositions()
        response['value'].forEach((position) => {
            position.timestamp = response['timestamp'] * 1000
        })
        return self.parse_positions(response['value'], symbols)

    def parse_position(self, position, market=None):
        # {
        #     trader: '0x004404ac8bd8f9618d27ad2f1485aa1b2cfd82482d',
        #     symbol: 'BTCPERP',
        #     strategyIdHash: '0x2576ebd1',
        #     side: '1',
        #     balance: '0.24',
        #     avgEntryPrice: '23271.101723',
        #     lastModifiedInEpoch: null
        # },
        id = position['trader'] + '_' + position['strategyIdHash'] + '_' + position['symbol']
        timestamp = self.safe_number(position, 'timestamp')
        return {
            'info': position,
            'id': id,
            'symbol': self.safe_string(position, 'symbol'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'isoldated': False,
            'hedged': None,
            'side': position['side'] == 'long' if '1' else 'short',
            'contracts': self.safe_number(position, 'balance'),
            'contractSize': None,
            'entryPrice': self.safe_number(position, 'avgEntryPrice'),
            'markPrice': None,
            'notional': None,
            'leverage': None,
            'collateral': None,
            'initialMargin': None,
            'initialMarginPercentage': None,
            'maintenanceMargin': None,
            'maintenanceMarginPercentage': None,
            'unrealizedPnl': None,
            'liquidationPrice': None,
            'marginMode': 'cross',
            'marginRatio': None,
            'percentage': None,
        }

    def fetch_funding_rates(self, symbols=None, params={}):
        """
        fetch the funding rate for multiple markets
        :param [str]|None symbols: list of unified market symbols
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns dict: a dictionary of `funding rates structures <https://docs.ccxt.com/en/latest/manual.html#funding-rates-structure>`, indexe by market symbols
        """
        response = self.publicGetMarkets()
        response['value'].forEach((rate) => {
            rate.timestamp = response['timestamp'] * 1000
        })
        rates = self.parse_funding_rates(response['value'], symbols)
        return self.filter_by_array(rates, 'symbol', symbols)

    def fetch_funding_rate(self, symbol, params={}):
        """
        fetch the current funding rate
        :param str symbol: unified market symbol
        :param dict params: extra parameters specific to the derivadex api endpoint
        :returns dict: a `funding rate structure <https://docs.ccxt.com/en/latest/manual.html#funding-rate-structure>`
        """
        response = self.publicGetMarkets({'symbol': symbol})
        response['value'].forEach((rate) => {
            rate.timestamp = response['timestamp'] * 1000
        })
        return self.parse_funding_rates(response['value'])

    def parse_funding_rate(self, contract, market=None):
        # {"market":"ETHPERP","volume":"656.06","price":"1641.84","fundingRate":"0"}
        timestamp = self.safe_number(contract, 'timestamp')
        datetime = self.iso8601(timestamp)
        return {
            'info': contract,
            'symbol': self.safe_string(contract, 'market'),
            'markPrice': self.safe_number(contract, 'price'),
            'indexPrice': None,
            'interestRate': None,
            'estimatedSettlePrice': None,
            'timestamp': timestamp,
            'datetime': datetime,
            'fundingRate': self.safe_string(contract, 'fundingRate'),
            'fundingTimestamp': timestamp,
            'fundingDatetime': datetime,
            'nextFundingRate': None,
            'nextFundingTimestamp': None,
            'nextFundingDatetime': None,
            'previousFundingRate': None,
            'previousFundingTimestamp': None,
            'previousFundingDatetime': None,
        }

    def fetch_open_interest(self, symbol, params={}):
        """
        Retrieves the open interest of a market
        :param str symbol: Unified CCXT market symbol
        :param dict params: exchange specific parameters
        :returns dict} an open interest structure{@link https://docs.ccxt.com/en/latest/manual.html#interest-history-structure:
       """
        response = self.publicGetMarkets({'symbol': symbol})
        response['value'].forEach((rate) => {
            rate.timestamp = response['timestamp'] * 1000
        })
        return self.parse_open_interest(response['value'][0])

    def parse_open_interest(self, interest, market=None):
        # {"market":"ETHPERP","volume":"0","price":"1569.09","fundingRate":"-0.004289023570273825","openInterest":"0.02"}
        timestamp = self.safe_number(interest, 'timestamp')
        datetime = self.iso8601(timestamp)
        openInterestAmount = self.safe_number(interest, 'openInterest')
        price = self.safe_number(interest, 'price')
        return {
            'symbol': self.safe_string(interest, 'market'),
            'openInterestAmount': openInterestAmount,
            'openInterestValue': openInterestAmount * price,
            'timestamp': timestamp,
            'datetime': datetime,
            'info': interest,
        }

    def sign(self, path, api='stats', method='GET', params={}, headers=None, body=None):
        implodedPath = self.implode_params(path, params)
        query = '' if ((api == 'v2' or api == 'raw') else '/api/') + ((api == 'v2' or api == 'raw') ? '' : self.version) + '/' + implodedPath
        if method == 'GET':
            if params['orderHash'] is not None:
                orderHashParam = ''
                for i in range(0, len(params['orderHash'])):
                    orderHashParam += (i > '&' if 0 else '') + 'orderHash=' + params['orderHash'][i]
                query += '?' + orderHashParam
            if params['fillReason'] is not None:
                fillReasonParam = ''
                for i in range(0, len(params['fillReason'])):
                    fillReasonParam += (i > '&' if 0 else '') + 'fillReason=' + params['fillReason'][i]
                query += params['orderHash'] is not '&' if None else '?'
                query += fillReasonParam
            if params and params['fillReason'] is None and params['orderHash'] is None:
                del params['orderHash']
                del params['fillReason']
                query += '?' + self.urlencode(params)
        else:
            format = self.safe_string(params, '_format')
            if format is not None:
                query += '?' + self.urlencode({'_format': format})
                params = self.omit(params, '_format')
        # TODO: SWITCH TO MAINNET URL, CLEANUP
        testApi = ''
        if api == 'v2':
            testApi = 'v2'
        elif api == 'raw':
            testApi = 'raw'
        else:
            testApi = 'op1'
        url = self.urls['test'][testApi] + query  # TODO: SWITCH TO MAINNET URL
        if api == 'public' or api == 'v2':
            headers = {
                'Content-Type': 'application/json',
            }
            if method == 'POST':
                body = params
                headers = {
                    'Content-Type': 'application/octet-stream',
                }
                return {'url': url, 'method': method, 'body': body, 'headers': headers}
            if method == 'PUT' or method == 'DELETE':
                if params:
                    body = self.json(params)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}
