<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\ExchangeError;
use ccxt\AuthenticationError;
use ccxt\ArgumentsRequired;
use ccxt\BadSymbol;
use ccxt\OrderNotFound;
use ccxt\Precise;
use React\Async;
use React\Promise;

class derivadex extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'derivadex',
            'name' => 'DerivaDEX',
            'countries' => array( 'JP' ), // Japan
            'version' => 'v1',
            'rateLimit' => 200, // TODO => add documentation for tiered rate limiting
            'pro' => false,
            'has' => array(
                'CORS' => null,
                'spot' => false,
                'margin' => false,
                'swap' => true,
                'future' => false,
                'option' => false,
                'addMargin' => false,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'cancelOrders' => false,
                'createOrder' => true,
                'createReduceOnlyOrder' => false,
                'editOrder' => true,
                'fetchBalance' => true,
                'fetchClosedOrders' => false,
                'fetchDepositAddress' => true,
                'fetchDepositAddresses' => false,
                'fetchDepositAddressesByNetwork' => false,
                'fetchFundingHistory' => false,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => false,
                'fetchFundingRates' => true,
                'fetchIndexOHLCV' => false,
                'fetchLedger' => false,
                'fetchLeverage' => false,
                'fetchLeverageTiers' => false,
                'fetchMarketLeverageTiers' => false,
                'fetchMarkets' => true,
                'fetchMarkOHLCV' => false,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenInterest' => true,
                'fetchOpenOrders' => false,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrders' => true,
                'fetchPosition' => false,
                'fetchPositions' => true,
                'fetchPositionsRisk' => false,
                'fetchPremiumIndexOHLCV' => false,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTrades' => true,
                'fetchTransactions' => false,
                'fetchTransfer' => false,
                'fetchTransfers' => false,
                'reduceMargin' => false,
                'setLeverage' => true,
                'setMargin' => false,
                'setMarginMode' => false,
                'setPositionMode' => false,
                'transfer' => false,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '1h' => '1h',
                '1d' => '1d',
            ),
            'urls' => array(
                'test' => array(
                    'public' => 'https://beta.derivadex.io',
                    'private' => 'https://beta.derivadex.io',
                    'stats' => 'https://beta.derivadex.io/stats',
                    'v2' => 'http://op1.ddx.one:15080/v2', // TODO => DELETE THIS
                    'op1' => 'http://op1.ddx.one:15080/stats', // TODO => delete this before submitting
                    'raw' => 'http://op1.ddx.one:15080', // TODO => delete this before submitting
                ),
                'logo' => 'https://gitlab.com/dexlabs/assets/-/raw/main/light-round.png',
                'api' => array(
                    'public' => 'https://exchange.derivadex.com',
                    'private' => 'https://exchange.derivadex.com',
                    'stats' => 'https://exchange.derivadex.com/stats',
                    'v2' => 'https://exchange.derivadex.com/v2',
                ),
                'www' => 'https://exchange.derivadex.com',
                'doc' => array(
                    'https://docs.derivadex.io',
                    'http://api.derivadex.io/',
                    'https://exchange.derivadex.com/api-docs',
                ),
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'account/{trader}/strategy/{strategyId}/adls' => 1,
                        'account/{trader}/strategy/{strategyId}/fills' => 1,
                        'account/{trader}/strategy/{strategyId}/' => 1,
                        'account/{trader}/strategy/{strategyId}/liquidations' => 1,
                        'account/{trader}/strategy/{strategyId}/order_book' => 1,
                        'account/{trader}/strategy/{strategyId}/order_intents' => 1,
                        'account/{trader}/strategy/{strategyId}/positions' => 1,
                        'account/{trader}/strategy/{strategyId}/strategy_updates' => 1,
                        'account/{trader}' => 1,
                        'account/{trader}/trader_updates' => 1,
                        'adl' => 1,
                        'ddx_fee_pool' => 1,
                        'epochs' => 1,
                        'fills' => 1,
                        'insurance_fund' => 1,
                        'liquidations' => 1,
                        'order_book' => 1,
                        'order_intents' => 1,
                        'positions' => 1,
                        'prices' => 1,
                        'specs' => 1,
                        'strategies' => 1,
                        'startegy_updates' => 1,
                        'trader_updates' => 1,
                        'traders' => 1,
                        'tx_logs' => 1,
                        'aggregations/collateral' => 1,
                        'aggregations/volume' => 1,
                        'markets' => 1,
                        'markets/order_book/L2' => 1,
                        'markets/tickers' => 1,
                        'snapshot/addresses' => 1,
                    ),
                ),
                'v2' => array(
                    'get' => array(
                        'rest/ohlcv' => 1,
                        'encryption-key' => 1,
                    ),
                    'post' => array(
                        'request' => 1,
                    ),
                ),
                'raw' => array(
                    'get' => array(
                        'snapshot/addresses' => 1,
                    ),
                ),
            ),
            'requiredCredentials' => array(
                'walletAddress' => true,
                'privateKey' => true,
                'apiKey' => false,
                'secret' => false,
            ),
            'precisionMode' => DECIMAL_PLACES,
            'options' => array(
                'defaultType' => 'swap',
                'defaultNetwork' => 'ERC20',
                'networks' => array(
                    'ETH' => 'ERC20',
                ),
                'networksById' => array(
                    'ETH' => 'ERC20',
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'feeSide' => 'get',
                    'tierBased' => false,
                    'percentage' => true,
                    'taker' => 0.002,
                    'maker' => 0.0,
                ),
            ),
            'encryptionKey' => null,
        ));
    }

    public function fetch_markets($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * retrieves data on all $markets for derivadex
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @return {[array]} an array of objects representing market data
             */
            $params['kind'] = 0;
            $response = Async\await($this->publicGetSpecs ($params));
            // {
            //     "value" => array(
            //         {
            //             "kind" => 0,
            //             "name" => "DDXPERP",
            //             "expr" => "\n(Market :$name "DDXPERP"\n :tick-size 0.1\n :max-order-notional 0\n :max-taker-price-deviation 0.02\n :min-order-size 0.0001\n)",
            //             "value" => array(
            //                 "tickSize" => "0.1",
            //                 "minOrderSize" => "0.0001",
            //                 "maxOrderNotional" => "0",
            //                 "maxTakerPriceDeviation" => "0.02"
            //             }
            //         ),
            //         {
            //             "kind" => 0,
            //             "name" => "BTCPERP",
            //             "expr" => "\n(Market :$name "BTCPERP"\n :tick-size 1\n :max-order-notional 1000000\n :max-taker-price-deviation 0.02\n :min-order-size 0.00001\n)",
            //             "value" => array(
            //                 "tickSize" => "1",
            //                 "minOrderSize" => "0.00001",
            //                 "maxOrderNotional" => "1000000",
            //                 "maxTakerPriceDeviation" => "0.02"
            //             }
            //         ),
            //         {
            //             "kind" => 0,
            //             "name" => "ETHPERP",
            //             "expr" => "\n(Market :$name "ETHPERP"\n :tick-size 0.1\n :max-order-notional 1000000\n :max-taker-price-deviation 0.02\n :min-order-size 0.0001\n)",
            //             "value" => {
            //                 "tickSize" => "0.1",
            //                 "minOrderSize" => "0.0001",
            //                 "maxOrderNotional" => "1000000",
            //                 "maxTakerPriceDeviation" => "0.02"
            //             }
            //         }
            //     ),
            //         "timestamp" => 1674260369,
            //         "success" => true
            // }
            $markets = $response['value'];
            return $markets->filter ((market) => market['name'] !== 'DDXPERP').map ((market) => array(
                $name = market['name'];
                $base = mb_substr($name, 0, -4 - 0);
                return array(
                    'id' => $name,
                    'symbol' => $name,
                    'base' => $base,
                    'quote' => 'USD',
                    'settle' => 'USDC',
                    'baseId' => strtolower($base),
                    'quoteId' => 'usd',
                    'settleId' => 'usdc',
                    'type' => 'swap',
                    'spot' => 'false',
                    'margin' => 'false',
                    'swap' => 'true',
                    'future' => 'false',
                    'option' => 'swap',
                    'active' => 'true',
                    'contract' => 'true',
                    'linear' => 'true',
                    'inverse' => 'false',
                    'taker' => '0.002',
                    'maker' => '0.000',
                    'precision' => array(
                        'amount' => 6,
                        'price' => 6,
                        'quote' => 6,
                    ),
                    'limits' => array(
                        'leverage' => array(
                            'min' => null,
                            'max' => 3,
                        ),
                        'amount' => array(
                            'min' => market['value']['minOrderSize'],
                            'max' => null,
                        ),
                        'price' => array(
                            'min' => market['value']['tickSize'],
                            'max' => null,
                        ),
                        'cost' => array(
                            'min' => null,
                            'max' => market['value']['maxOrderNotional'],
                        ),
                    ),
                    'info' => market,
                );
            ));
        }) ();
    }

    public function fetch_currencies($params = array ()) {
        /**
         * fetches all available currencies on an exchange
         * @param {array} $params extra parameters specific to the derivadex api endpoint
         * @return {array} an associative dictionary of currencies
         */
        $networks = array();
        $networks['ERC20'] = array(
            'info' => null,
            'id' => 'ETH',
            'network' => $this->network_id_to_code('ETH'),
            'active' => true,
            'deposit' => true,
            'withdraw' => true,
            'fee' => null,
        );
        return array(
            array(
                'id' => 'usdc',
                'code' => 'USDC',
                'name' => 'USDC',
                'active' => true,
                'fee' => 0,
                'precision' => 6,
                'deposit' => true,
                'withdraw' => true,
                'limits' => array(
                    'deposit' => array(
                        'min' => 1000,
                        'max' => 1000000,
                    ),
                ),
                'networks' => $networks,
                'info' => null,
            ),
            array(
                'id' => 'ddx',
                'code' => 'DDX',
                'name' => 'DDX',
                'active' => false,
                'fee' => 0,
                'precision' => 6,
                'deposit' => true,
                'withdraw' => true,
                'limits' => array(
                    'deposit' => array(
                        'min' => 0.000001,
                        'max' => null,
                    ),
                ),
                'networks' => $networks,
                'info' => null,
            ),
        );
    }

    public function fetch_ticker($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetches a price $ticker, a statistical calculation with the information calculated over the past 24 hours for a specific $market
             * @param {string} $symbol unified $symbol of the $market to fetch the $ticker for
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#$ticker-structure $ticker structure}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $tickers = Async\await($this->fetch_tickers([ $market['id'] ], $params));
            $ticker = $this->safe_value($tickers, $market['id']);
            if ($ticker === null) {
                throw new BadSymbol($this->id . ' fetchTicker() $symbol ' . $market['id'] . ' not found');
            }
            return $ticker;
        }) ();
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
             * @param {[string]|null} $symbols unified $symbols of the markets to fetch the $ticker for, all market tickers are returned if not assigned
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @return {array} an array of {@link https://docs.ccxt.com/en/latest/manual.html#$ticker-structure $ticker structures}
             */
            Async\await($this->load_markets());
            $symbols = $symbols === null ? is_array($this->markets) : $this->market_symbols($symbols) ? array_keys($this->markets) : $this->market_symbols($symbols) : array();
            $result = array();
            for ($i = 0; $i < count($symbols); $i++) {
                $ticker = Async\await($this->construct_ticker($symbols[$i]));
                if ($ticker !== null) {
                    $result[$symbols[$i]] = $ticker;
                }
            }
            return $result;
        }) ();
    }

    public function construct_ticker($symbol) {
        return Async\async(function () use ($symbol) {
            $params = array();
            $params['symbol'] = $symbol;
            $params['depth'] = 1;
            list($orderBookResponse, $tickerResponse) = Async\await(Promise\all(array(
                $this->publicGetMarketsOrderBookL2 ($params),
                $this->publicGetMarketsTickers (array( 'symbol' => $symbol )),
            )));
            $orderBookValue = $orderBookResponse['value'];
            $bid = $this->safe_string($orderBookValue[0], 'price');
            $bidVolume = $this->safe_string($orderBookValue[0], 'amount');
            $ask = $this->safe_string($orderBookValue[1], 'price');
            $askVolume = $this->safe_string($orderBookValue[1], 'amount');
            $ticker = $tickerResponse['value'][0];
            $timestamp = $this->safe_string($tickerResponse, 'timestamp');
            return array(
                'symbol' => $symbol,
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'high' => $this->safe_string($ticker, 'high'),
                'low' => $this->safe_string($ticker, 'low'),
                'bid' => $bid,
                'bidVolume' => $bidVolume,
                'ask' => $ask,
                'askVolume' => $askVolume,
                'vwap' => $this->safe_string($ticker, 'volumeWeightedAveragePrice'),
                'open' => $this->safe_string($ticker, 'open'),
                'close' => $this->safe_string($ticker, 'close'),
                'last' => $this->safe_string($ticker, 'close'),
                'previousClose' => null,
                'change' => $this->safe_string($ticker, 'change'),
                'percentage' => $this->safe_string($ticker, 'percentage'),
                'average' => null,
                'baseVolume' => $this->safe_string($ticker, 'baseVolume'),
                'quoteVolume' => $this->safe_string($ticker, 'notionalVolume'),
                'info' => array( $orderBookResponse, $tickerResponse ),
            );
        }) ();
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetch all trades made by the user
             * @param {string|null} $symbol unified $market $symbol
             * @param {int|null} $since the earliest time in ms to fetch trades for
             * @param {int|null} $limit the maximum number of trades structures to retrieve
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @param {string|null} $params->order the chronological order of items in the $response - 'asc' or 'desc'
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#trade-structure trade structures}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
                'trader' => $this->walletAddress,
                'strategy' => 'main',
                'fillReason' => '0',
            );
            if ($limit !== null) {
                $request['limit'] = $limit; // default 500
            }
            if ($since !== null) {
                $request['since'] = $since / 1000;
            }
            $request['order'] = $params['order'] !== null ? $params['order'] : 'asc';
            $extendedRequest = array_merge($request, $params);
            if ($extendedRequest['trader'] === null) {
                throw new AuthenticationError($this->id . ' fetchMyTrades() walletAddress is null, set $this->walletAddress or "address" in params');
            }
            $response = Async\await($this->publicGetFills ($extendedRequest));
            $traderAddressWithDiscriminant = $this->add_discriminant($this->walletAddress);
            $mainStrategyIdHash = $this->get_main_strategy_id_hash();
            return Async\await($this->parse_trades_custom($response, $market, $since, $limit, $traderAddressWithDiscriminant, $mainStrategyIdHash));
        }) ();
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * get the list of most recent trades for a particular $symbol
             * @param {string} $symbol unified $symbol of the $market to fetch trades for
             * @param {int|null} $since timestamp in ms of the earliest trade to fetch
             * @param {int|null} $limit the maximum amount of trades to fetch
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @param {string|null} $params->order the chronological order of items in the $response - 'asc' or 'desc'
             * @return {[array]} a list of ~@link https://docs.ccxt.com/en/latest/manual.html?#public-trades trade structures~
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
                'fillReason' => '0',
            );
            if ($limit !== null) {
                $request['limit'] = $limit; // default 500
            }
            if ($since !== null) {
                $request['since'] = $since / 1000;
            }
            $request['order'] = $params['order'] !== null ? $params['order'] : 'asc';
            $response = Async\await($this->publicGetFills (array_merge($request, $params)));
            // {
            //     value => array(
            //       array(
            //         epochId => '27',
            //         txOrdinal => '6',
            //         ordinal => '0',
            //         makerOrderHash => '0x87686e3ffa6b2e9c8a229a9b7fe948b504db94d376ce8e494f',
            //         amount => '0.05',
            //         $symbol => 'BTCPERP',
            //         price => '22790',
            //         makerFee => '0',
            //         makerFeeSymbol => 'USDC',
            //         makerRealizedPnl => '0',
            //         takerOrderHash => '0x08fd0fd22dd23f3550d4edea3e37cceab4b9612116c14d71c0',
            //         takerFee => '2.279',
            //         takerFeeSymbol => 'USDC',
            //         takerRealizedPnl => '0',
            //         reason => '0',
            //         createdAt => '2023-01-25T20:13:12.574Z',
            //         liquidatedTrader => null,
            //         liquidatedStrategyIdHash => null
            //       ),
            //       array(
            //         epochId => '27',
            //         txOrdinal => '7',
            //         ordinal => '0',
            //         makerOrderHash => '0x87686e3ffa6b2e9c8a229a9b7fe948b504db94d376ce8e494f',
            //         amount => '0.01',
            //         $symbol => 'BTCPERP',
            //         price => '22790',
            //         makerFee => '0',
            //         makerFeeSymbol => 'USDC',
            //         makerRealizedPnl => '0',
            //         takerOrderHash => '0x80b89184c49b710455ec17948785a07f4bb357561490a3e683',
            //         takerFee => '0.4558',
            //         takerFeeSymbol => 'USDC',
            //         takerRealizedPnl => '0',
            //         reason => '0',
            //         createdAt => '2023-01-25T20:13:18.578Z',
            //         liquidatedTrader => null,
            //         liquidatedStrategyIdHash => null
            //       ),
            //     )
            // }
            return Async\await($this->parse_trades_custom($response, $market, $since, $limit));
        }) ();
    }

    public function get_order_intents($trades) {
        return Async\async(function () use ($trades) {
            $result = array();
            $params = array(
                'orderHash' => array(),
            );
            for ($i = 0; $i < count($trades); $i++) {
                $params['orderHash'][] = $trades[$i]['takerOrderHash'];
            }
            $orderIntentResponse = Async\await($this->publicGetOrderIntents ($params));
            $orderIntentResponseValue = $orderIntentResponse['value'];
            for ($i = 0; $i < count($orderIntentResponseValue); $i++) {
                $result[$orderIntentResponseValue[$i]['orderHash']] = $orderIntentResponseValue[$i];
            }
            return $result;
        }) ();
    }

    public function parse_trades_custom($trades, $market = null, $since = null, $limit = null, $trader = null, $strategy = null) {
        return Async\async(function () use ($trades, $market, $since, $limit, $trader, $strategy) {
            $trades = $this->to_array($trades);
            $result = array();
            $orderIntents = Async\await($this->get_order_intents($trades[0]));
            for ($i = 0; $i < count($trades[0]); $i++) {
                $trade = $this->parse_trade_custom($trades[0][$i], $orderIntents, $trader, $strategy);
                $result[] = $trade;
            }
            $result = $this->sort_by_2($result, 'timestamp', 'id');
            $symbol = ($market !== null) ? $market['symbol'] : null;
            $tail = ($since === null);
            return $this->filter_by_symbol_since_limit($result, $symbol, $since, $limit, $tail);
        }) ();
    }

    public function parse_trade_custom($trade, $orderIntents, $trader = null, $strategy = null) {
        $id = $this->safe_string($trade, 'takerOrderHash') . '_' . $this->safe_string($trade, 'epochId') . '_' . $this->safe_string($trade, 'txOrdinal');
        $timestamp = $this->parse8601($this->safe_string($trade, 'createdAt'));
        $datetime = $this->iso8601($timestamp);
        $symbol = $this->safe_string($trade, 'symbol');
        $order = $this->safe_string($trade, 'takerOrderHash');
        $price = $this->safe_string($trade, 'price');
        $amount = $this->safe_string($trade, 'amount');
        $fee = array(
            'cost' => $this->safe_string($trade, 'takerFee'),
            'currency' => $this->safe_string($trade, 'takerFeeSymbol'),
        );
        $takerOrderHash = $this->safe_string($trade, 'takerOrderHash');
        $sideNumber = $this->safe_integer($orderIntents[$takerOrderHash], 'side');
        $orderTypeNumber = $this->safe_integer($orderIntents[$takerOrderHash], 'orderType');
        $side = $sideNumber === 0 ? 'buy' : 'sell';
        $orderType = $this->get_order_type($orderTypeNumber);
        // liquidations have null $takerOrderHash
        $takerOrMaker = $takerOrderHash !== null ? 'taker' : null;
        if ($trader !== null && $strategy !== null && $this->safe_string($trade, 'makerOrderTrader') === strtolower($trader) && $this->safe_string($trade, 'makerOrderStrategyIdHash') === $strategy) {
            $takerOrMaker = 'maker';
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'symbol' => $symbol,
            'id' => $id,
            'order' => $order,
            'type' => $orderType,
            'takerOrMaker' => $takerOrMaker,
            'side' => $side,
            'price' => $price,
            'cost' => null,
            'amount' => $amount,
            'fee' => $fee,
        ));
    }

    public function parse_trade($trade, $market = null) {
        $id = $this->safe_string($trade, 'takerOrderHash') . '_' . $this->safe_string($trade, 'epochId') . '_' . $this->safe_string($trade, 'txOrdinal');
        $timestamp = $this->parse8601($this->safe_string($trade, 'createdAt'));
        $datetime = $this->iso8601($timestamp);
        $symbol = $this->safe_string($trade, 'symbol');
        $order = $this->safe_string($trade, 'takerOrderHash');
        $price = $this->safe_string($trade, 'price');
        $amount = $this->safe_string($trade, 'amount');
        $fee = array(
            'cost' => $this->safe_string($trade, 'takerFee'),
            'currency' => $this->safe_string($trade, 'takerFeeSymbol'),
        );
        $takerOrderHash = $this->safe_string($trade, 'takerOrderHash');
        // liquidations have null $takerOrderHash
        $takerOrMaker = $takerOrderHash !== null ? 'taker' : null;
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'symbol' => $symbol,
            'id' => $id,
            'order' => $order,
            'type' => null,
            'takerOrMaker' => $takerOrMaker,
            'side' => null,
            'price' => $price,
            'cost' => null,
            'amount' => $amount,
            'fee' => $fee,
        ));
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $limit, $params) {
            /**
             * fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
             * @param {string} $symbol unified $symbol of the $market to fetch the $order book for
             * @param {int|null} $limit the maximum $amount of $order book entries to return
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @return {array} A dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#$order-book-structure $order book structures} indexed by $market symbols
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['depth'] = $limit;
            }
            $response = Async\await($this->publicGetOrderBook (array_merge($request, $params)));
            // value => array(
            //     array(
            //       traderAddress => '0x004404ac8bd8f9618d27ad2f1485aa1b2cfd82482d',
            //       strategyId => 'main',
            //       orderHash => '0x2e401956ae605a3a222bd92533260103a23a963e6e55b066a0',
            //       $symbol => 'BTCPERP',
            //       $amount => '0.035',
            //       $price => '23000',
            //       $side => '0',
            //       originalAmount => '0.04',
            //       bookOrdinal => '0'
            //     ),
            //     {
            //       traderAddress => '0x004404ac8bd8f9618d27ad2f1485aa1b2cfd82482d',
            //       strategyId => 'main',
            //       orderHash => '0x746be891d408f6e415760241c86d9c852a17514d59299a78de',
            //       $symbol => 'BTCPERP',
            //       $amount => '0.08',
            //       $price => '24000',
            //       $side => '1',
            //       originalAmount => '0.08',
            //       bookOrdinal => '1'
            //     }
            //   )
            $responseValue = $response['value'];
            $timestamp = $this->safe_number($response, 'timestamp') * 1000;
            $result = array(
                'symbol' => $market['id'],
                'bids' => array(),
                'asks' => array(),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'nonce' => null,
            );
            for ($i = 0; $i < count($responseValue); $i++) {
                $order = $responseValue[$i];
                $side = ($order['side'] === '0') ? 'bids' : 'asks';
                $amount = $this->safe_number($order, 'amount');
                $price = $this->safe_number($order, 'price');
                $result[$side][] = array( $price, $amount );
            }
            $result['bids'].reverse ();
            return $result;
        }) ();
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            /**
             * fetches historical candlestick data containing the open, high, low, and close price, and the volume of a $market
             * @param {string} $symbol unified $symbol of the $market to fetch OHLCV data for
             * @param {string} $timeframe the length of time each candle represents
             * @param {int|null} $since timestamp in ms of the earliest candle to fetch
             * @param {int|null} $limit the maximum amount of candles to fetch
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @return {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $fromTimestamp = $this->get_time_for_ohlcv_request($this->timeframes[$timeframe], $since, $limit);
            $request = array(
                'symbol' => $market['id'],
                'interval' => $this->timeframes[$timeframe],
                'from' => $fromTimestamp / 1000,
            );
            if ($limit !== null) {
                $request['to'] = $this->get_to_param_for_ohlcv_request($this->timeframes[$timeframe], $fromTimestamp, $limit) / 1000;
            }
            if ($since !== null) {
                $request['since'] = $since;
            }
            $response = Async\await($this->v2GetRestOhlcv (array_merge($request, $params)));
            return $this->parse_ohlcvs($response['ohlcv'], $market, $timeframe, $since, $limit);
        }) ();
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        $timestamp = $this->safe_integer($ohlcv, 'timestamp');
        $open = $this->safe_number($ohlcv, 'open');
        $high = $this->safe_number($ohlcv, 'high');
        $low = $this->safe_number($ohlcv, 'low');
        $close = $this->safe_number($ohlcv, 'close');
        $volume = $this->safe_number($ohlcv, 'volume');
        return array( $timestamp, $open, $high, $low, $close, $volume );
    }

    public function get_time_for_ohlcv_request($interval, $time, $limit) {
        $msInMinute = 60 * 1000;
        $msInHour = 60 * 1000 * 60;
        $msInDay = 60 * 1000 * 60 * 24;
        if ($time === null) {
            $duration = $this->parse_timeframe($interval);
            $time = $this->milliseconds() - $duration * $limit * 1000 - 1000;
        }
        if ($interval === '1m') {
            return (int) ceil($time / $msInMinute) * $msInMinute;
        }
        if ($interval === '1h') {
            return (int) ceil($time / $msInHour) * $msInHour;
        }
        if ($interval === '1d') {
            return (int) ceil($time / $msInDay) * $msInDay;
        }
    }

    public function get_to_param_for_ohlcv_request($interval, $from, $limit) {
        $msInMinute = 60 * 1000;
        $msInHour = 60 * 1000 * 60;
        $msInDay = 60 * 1000 * 60 * 24;
        if ($interval === '1m') {
            return $from . ($msInMinute * $limit);
        }
        if ($interval === '1h') {
            return $from . ($msInHour * $limit);
        }
        if ($interval === '1d') {
            return $from . ($msInDay * $limit);
        }
    }

    public function wait($ms) {
        return Async\async(function () use ($ms) {
            // eslint-disable-next-line no-promise-executor-return
            Async\await(new Promise ((resolve) => setTimeout (resolve, $ms)));
        }) ();
    }

    public function get_sequenced_order($operatorResponse, $lookbackLimit = null) {
        return Async\async(function () use ($operatorResponse, $lookbackLimit) {
            /**
             * fetches information on an $order made by the user
             * @param {array} $operatorResponse the operator $response object associated with a derivadex createOrder() request
             * @param {int|null} $lookbackLimit the maximum number of $order intents to lookback through to find an $order intent. You may need a higher $lookbackLimit value if many orders have been placed since the $operatorResponse you are searching for returned
             * @return {array} An {@link https://docs.ccxt.com/en/latest/manual.html#$order-structure $order structure}
             */
            $params = array(
                'trader' => $this->walletAddress,
                'strategyId' => 'main',
                'order' => 'desc',
            );
            if ($lookbackLimit !== null) {
                $params['limit'] = $lookbackLimit;
            }
            $response = Async\await($this->publicGetAccountTraderStrategyStrategyIdOrderIntents ($params));
            $order = $response['value'].find ((intent) => intent.nonce === $operatorResponse->c.nonce);
            if ($order === null) {
                Async\await($this->wait(1000)); // retry after 1 second
                $response = Async\await($this->publicGetAccountTraderStrategyStrategyIdOrderIntents ($params));
                $order = $response['value'].find ((intent) => intent.nonce === $operatorResponse->c.nonce);
                if ($order === null) {
                    throw new OrderNotFound($this->id . ' getSequencedOrder() could not find the $order intent associated with this operator response');
                }
            }
            return Async\await($this->parse_order($order));
        }) ();
    }

    public function fetch_public_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple public orders made in a $market
             * @param {string|null} $symbol unified $market $symbol of the $market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of  orde structures to retrieve
             * @param {string|null} $params->order the chronological order of items in the $response - 'asc' or 'desc'
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            if ($since !== null) {
                $request['since'] = $since / 1000;
            }
            $request['order'] = $params['order'] !== null ? $params['order'] : 'asc';
            $response = Async\await($this->publicGetOrderIntents ($request));
            return Async\await($this->parse_orders_custom($response['value'], $market, $since, $limit));
        }) ();
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * fetches information on an order made by the user
             * @param {string|null} $symbol unified $symbol of the $market the order was made in
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @return {array} An {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure}
             */
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' fetchOrders() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'orderHash' => array( $id ),
            );
            $response = Async\await($this->publicGetOrderIntents ($request));
            return Async\await($this->parse_order($response['value'][0], $market));
        }) ();
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            /**
             * fetches information on multiple orders made by the user
             * @param {string|null} $symbol unified $market $symbol of the $market orders were made in
             * @param {int|null} $since the earliest time in ms to fetch orders for
             * @param {int|null} $limit the maximum number of order structures to retrieve
             * @param {string|null} $params->order the chronological order of items in the $response - 'asc' or 'desc'
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $market['id'],
                'trader' => $this->walletAddress,
                'strategyId' => 'main',
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            if ($since !== null) {
                $request['since'] = $since / 1000;
            }
            $request['order'] = $params['order'] !== null ? $params['order'] : 'asc';
            $response = Async\await($this->publicGetAccountTraderStrategyStrategyIdOrderIntents ($request));
            return Async\await($this->parse_orders_custom($response['value'], $market, $since, $limit));
        }) ();
    }

    public function parse_orders_custom($orders, $market = null, $since = null, $limit = null, $params = array ()) {
        $results = array();
        if (gettype($orders) === 'array' && array_keys($orders) === array_keys(array_keys($orders))) {
            for ($i = 0; $i < count($orders); $i++) {
                $order = array_merge(await $this->parse_order($orders[$i], $market), $params);
                $results[] = $order;
            }
        } else {
            $ids = is_array($orders) ? array_keys($orders) : array();
            for ($i = 0; $i < count($ids); $i++) {
                $id = $ids[$i];
                $order = array_merge($this->parse_order(array_merge(array( 'id' => $id ), $orders[$id]), $market), $params);
                $results[] = $order;
            }
        }
        $results = $this->sort_by($results, 'timestamp');
        $symbol = ($market !== null) ? $market['symbol'] : null;
        $tail = $since === null;
        return $this->filter_by_symbol_since_limit($results, $symbol, $since, $limit, $tail);
    }

    public function parse_order($order, $market = null) {
        return Async\async(function () use ($order, $market) {
            // {
            //     "epochId":"1",
            //     "txOrdinal":"7",
            //     "orderHash":"0x2e401956ae605a3a222bd92533260103a23a963e6e55b066a0",
            //     "symbol":"BTCPERP",
            //     "amount":"0.04",
            //     "price":"23000",
            //     "side":0,
            //     "orderType":0,
            //     "stopPrice":"0",
            //     "nonce":"0x00000000000000000000000000000000000000000000000000000185f46343ae",
            //     "signature":"0xe5de522ee59134005016dd9e1f59b625052551c2f722261c3a31060c792384ba0152361624013a46685adf163335e4cc8006bfedfadb3896c2f5910d1391fc131b",
            //     "createdAt":"2023-01-27T18:00:26.960Z",
            //     "traderAddress":"0x004404ac8bd8f9618d27ad2f1485aa1b2cfd82482d",
            //     "strategyId":"main"
            // }
            $id = $this->safe_string($order, 'orderHash');
            $datetime = $this->safe_string($order, 'createdAt');
            $timestamp = $this->parse8601($datetime);
            $symbol = $this->safe_string($order, 'symbol');
            $orderHash = $this->safe_string($order, 'orderHash');
            $sideNumber = $this->safe_integer($order, 'side');
            $orderTypeNumber = $this->safe_integer($order, 'orderType');
            $side = $sideNumber === 0 ? 'buy' : 'sell';
            $price = $this->safe_string($order, 'price');
            $amount = $this->safe_string($order, 'amount');
            $params = array(
                'orderHash' => array( $orderHash ),
                'fillReason' => array( 0, 1, 2 ),
            );
            $fillResponse = Async\await($this->publicGetFills ($params));
            $fills = $fillResponse['value'];
            list($status, $filled) = $this->get_order_status_and_filled_amount($fills, $amount);
            $orderType = $this->get_order_type($orderTypeNumber);
            return $this->safe_order(array(
                'id' => $id,
                'clientOrderId' => null,
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'lastTradeTimestamp' => null,
                'status' => $status,
                'symbol' => $symbol,
                'type' => $orderType,
                'timeInForce' => 'GTC',
                'side' => $side,
                'price' => $price,
                'average' => null,
                'amount' => $amount,
                'filled' => $filled,
                'remaining' => $this->parse_number($amount) - $filled,
                'cost' => null,
                'trades' => null,
                'fee' => null,
                'info' => array( $order, $fills ),
            ), $market);
        }) ();
    }

    public function get_order_status_and_filled_amount($fills, $orderAmount) {
        $filledAmount = 0;
        $isCancel = false;
        for ($i = 0; $i < count($fills); $i++) {
            if ($fills[$i]['reason'] === '2') {
                $isCancel = true;
            } else {
                $filledAmount .= $this->parse_number($fills[$i]['amount']);
            }
        }
        if ($filledAmount === $this->parse_number($orderAmount)) {
            return array( 'closed', $filledAmount );
        }
        if ($isCancel) {
            return array( 'canceled', $filledAmount );
        }
        return array( 'open', $filledAmount );
    }

    public function get_order_type($orderTypeNumber) {
        if ($orderTypeNumber === 0) {
            return 'limit';
        } elseif ($orderTypeNumber === 1) {
            return 'market';
        } elseif ($orderTypeNumber === 2) {
            return 'stop';
        }
    }

    public function order_type_to_int($orderTypeString) {
        if ($orderTypeString === 'Limit') {
            return 0;
        } elseif ($orderTypeString === 'Market') {
            return 1;
        } else {
            return 2;
        }
    }

    public function order_side_to_int($orderSide) {
        if ($orderSide === 'Bid') {
            return 0;
        } else {
            return 1;
        }
    }

    public function update_profile($payFeesInDDX) {
        return Async\async(function () use ($payFeesInDDX) {
            /**
             * update a trader profile
             * @param {bool} $payFeesInDDX whether to pay trading fees in DDX or not.
             * @return {bool} whether the trader profile was updated successfully
             */
            $isAuthenticated = $this->check_required_credentials();
            if (!$isAuthenticated) {
                throw new AuthenticationError($this->id . ' updateProfile endpoint requires privateKey and walletAddress credentials');
            }
            $orderIntent = $this->get_operator_profile_update_intent($payFeesInDDX);
            $operatorResponse = Async\await($this->get_operator_response_for_order_intent($orderIntent, 'ProfileUpdate'));
            if ($operatorResponse['t'] !== 'Sequenced') {
                throw new ExchangeError($this->id . `updateProfile request failed with error $array($operatorResponse['t']), error contents => $array($this->json($operatorResponse['c']))`);
            }
            return true;
        }) ();
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * cancel all open orders
             * @param {string|null} $symbol unified market $symbol, only orders in the market of this $symbol are cancelled when $symbol is not null
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @param {string|null} $params->strategyId the trader strategyId for which to cancel all orders
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structures}
             */
            $isAuthenticated = $this->check_required_credentials();
            if (!$isAuthenticated) {
                throw new AuthenticationError($this->id . ' cancelAllOrders endpoint requires privateKey and walletAddress credentials');
            }
            $strategy = $params['strategyId'] === null ? 'main' : $params['strategyId'];
            $orderIntent = $this->get_operator_cancel_all_orders_intent($strategy);
            $operatorResponse = Async\await($this->get_operator_response_for_order_intent($orderIntent, 'CancelAll'));
            if ($operatorResponse['t'] !== 'Sequenced') {
                throw new ExchangeError($this->id . `cancelAllOrders request failed with error $array($operatorResponse['t']), error contents => $array($this->json($operatorResponse['c']))`);
            }
            return $operatorResponse;
        }) ();
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        return Async\async(function () use ($id, $symbol, $params) {
            /**
             * cancels an open order
             * @param {string} $id order $id
             * @param {string|null} $symbol not used by derivadex cancelOrder ()
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @return {array} An {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure}
             */
            $isAuthenticated = $this->check_required_credentials();
            if (!$isAuthenticated) {
                throw new AuthenticationError($this->id . ' cancelOrder endpoint requires privateKey and walletAddress credentials');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $orderIntent = $this->get_operator_cancel_order_intent($market['id'], $id);
            $operatorResponse = Async\await($this->get_operator_response_for_order_intent($orderIntent, 'CancelOrder'));
            $timestamp = Date.now ();
            if ($operatorResponse['t'] !== 'Sequenced') {
                throw new ExchangeError($this->id . `cancelOrder request failed with error $array($operatorResponse['t']), error contents => $array($this->json($operatorResponse['c']))`);
            }
            return $this->safe_order(array(
                'id' => null,
                'clientOrderId' => null,
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'lastTradeTimestamp' => null,
                'status' => null,
                'symbol' => $market['id'],
                'type' => null,
                'timeInForce' => 'GTC',
                'side' => null,
                'price' => null,
                'average' => null,
                'amount' => null,
                'filled' => null,
                'remaining' => null,
                'cost' => null,
                'trades' => null,
                'fee' => null,
                'info' => $operatorResponse,
            ), $market);
        }) ();
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            /**
             * create a trade order
             * @param {string} $symbol unified $symbol of the $market to create an order in
             * @param {string} $type 'market' or 'limit'
             * @param {string} $side 'buy' or 'sell'
             * @param {float} $amount how much of currency you want to trade in units of base currency
             * @param {float|null} $price the $price at which the order is to be fullfilled, in units of the quote currency, ignored in $market orders
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @param {bool|null} $params->getOrderConfirmation // if set to true, createOrder will return an order structure, otherwise createOrder will return the raw operator response.
             * @return {array} an {@link https://docs.ccxt.com/en/latest/manual.html#order-structure order structure}
             */
            $isAuthenticated = $this->check_required_credentials();
            if (!$isAuthenticated) {
                throw new AuthenticationError($this->id . ' createOrder endpoint requires privateKey and walletAddress credentials');
            }
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $orderType = $this->capitalize($type);
            $orderIntent = $this->get_operator_submit_order_intent($market['id'], $side, $orderType, $amount, $price);
            $operatorResponse = Async\await($this->get_operator_response_for_order_intent($orderIntent, 'Order'));
            if ($operatorResponse['t'] !== 'Sequenced') {
                throw new ExchangeError($this->id . ` createOrder request failed with error $array($this->json($operatorResponse['t'])), error contents => $array($this->json($operatorResponse['c']))`);
            }
            if (!$params->getOrderConfirmation) {
                return $operatorResponse;
            }
            return Async\await($this->get_sequenced_order($operatorResponse, 10));
        }) ();
    }

    public function get_operator_response_for_order_intent($orderIntent, $requestType) {
        return Async\async(function () use ($orderIntent, $requestType) {
            $scaledOrderIntent = $requestType === 'Order' ? $this->get_scaled_order_intent($orderIntent) : $orderIntent;
            $encryptionKey = $this->encryptionKey;
            if ($encryptionKey === null) {
                $encryptionKey = Async\await($this->v2GetEncryptionKey ());
                $this->encryptionKey = $encryptionKey;
            }
            // $addressesResponse = $this->rawGetSnapshotAddresses (array( 'contractDeployment' => 'beta' )); // TODO => switch to mainnet deployment
            $orderIntentData = $this->get_order_intent_typed_data(
                $scaledOrderIntent,
                // $addressesResponse['chainId'],
                100, // TODO => use mainnet chainId
                // $addressesResponse['addresses']['derivaDEXAddress']
                '0x48bacb9266a570d521063ef5dd96e61686dbe788', // TODO => use mainnet derivaDEXAddress
                $requestType
            );
            // $typedData = $this->transform_typed_data_for_ethers($orderIntentData);
            $signature = $this->sign_typed_data(Buffer.from ($this->privateKey, 'hex'), array( 'data' => $orderIntentData ));
            $orderIntent['signature'] = $signature;
            if ($requestType === 'Order') {
                $orderIntent['amount'] = (string) $orderIntent['amount'];
                $orderIntent['price'] = (string) $orderIntent['price'];
                $orderIntent['stopPrice'] = (string) $orderIntent['stopPrice'];
            }
            $intent = array( 't' => $requestType, 'c' => $orderIntent );
            $encryptedIntent = Async\await($this->encrypt_intent($encryptionKey, $intent));
            $buffer = Buffer.from (str_replace(/^0x/, '', $encryptedIntent), 'hex');
            return Async\await($this->v2PostRequest ($buffer));
        }) ();
    }

    public function add_discriminant($traderAddress) {
        // TODO => look up / resolve discriminant from chainId -- hard coding 00 for ethereum for now
        $prefix = '0x00';
        return `${$prefix}$array(mb_substr($traderAddress, 2))`;
    }

    public function as_nonce($num) {
        return `0x$array($num->toString (16).padStart (64, '0'))`;
    }

    public function get_operator_submit_order_intent($symbol, $side, $orderType, $amount, $price) {
        return array(
            'traderAddress' => $this->walletAddress,
            'symbol' => $symbol,
            'strategy' => 'main',
            'side' => $side === 'buy' ? 'Bid' : 'Ask',
            'orderType' => $orderType,
            'nonce' => $this->as_nonce(Date.now ()),
            'amount' => new Precise (string) ($amount),
            'price' => $price === null ? new Precise ('0') : new Precise (string) ($price),
            'stopPrice' => new Precise ('0'),
            'signature' => '0x0',
        );
    }

    public function get_operator_cancel_order_intent($symbol, $orderHash) {
        $ZERO_PADDING = '00000000000000';
        return array(
            'symbol' => $symbol,
            'nonce' => $this->as_nonce(Date.now ()),
            'signature' => '0x',
            'orderHash' => $orderHash . $ZERO_PADDING,
        );
    }

    public function get_operator_cancel_all_orders_intent($strategyId) {
        return array(
            'strategyId' => $strategyId,
            'nonce' => $this->as_nonce(Date.now ()),
            'signature' => '0x',
        );
    }

    public function get_operator_profile_update_intent($payFeesInDDX) {
        return array(
            'payFeesInDdx' => $payFeesInDDX,
            'nonce' => $this->as_nonce(Date.now ()),
            'signature' => '0x',
        );
    }

    public function get_scaled_order_intent($intent) {
        $operatorDecimals = 6;
        $operatorDecimalMultiplier = new Precise ((10 ** (string) $operatorDecimals));
        return array(
            'traderAddress' => $intent['traderAddress'],
            'symbol' => $intent['symbol'],
            'strategy' => $intent['strategy'],
            'side' => $intent['side'],
            'orderType' => $intent['orderType'],
            'nonce' => $intent['nonce'],
            'amount' => $intent['amount'].mul ($operatorDecimalMultiplier),
            'price' => $intent['price'].mul ($operatorDecimalMultiplier),
            'stopPrice' => $intent['stopPrice'].mul ($operatorDecimalMultiplier),
            'signature' => $intent['signature'],
        );
    }

    public function transform_typed_data_for_ethers($typedData) {
        return array(
            'domain' => $typedData->domain,
            'types' => $this->omit($typedData->types, 'EIP712Domain'),
            'value' => $typedData->message,
        );
    }

    public function encode_string_into_bytes32($str) {
        $encoder = new TextEncoder ();
        $encodedStr = $encoder->encode ($str);
        $lengthHex = strlen($encodedStr).toString (16);
        $paddedLengthHex = str_pad($lengthHex, 2, '0', STR_PAD_LEFT);
        $bytes32Str = '0x' . $paddedLengthHex . Buffer.from ($encodedStr).toString ('hex').padEnd (62, '0');
        return $bytes32Str;
    }

    public function get_order_intent_typed_data($orderIntent, $chainId, $verifyingContractAddress, $requestType) {
        if ($requestType === 'Order') {
            return $this->create_order_intent_typed_data($orderIntent, $chainId, $verifyingContractAddress);
        }
        if ($requestType === 'CancelOrder') {
            return $this->cancel_order_intent_typed_data($orderIntent, $chainId, $verifyingContractAddress);
        }
        if ($requestType === 'CancelAll') {
            return $this->cancel_all_orders_intent_typed_data($orderIntent, $chainId, $verifyingContractAddress);
        }
        if ($requestType === 'ProfileUpdate') {
            return $this->profile_update_intent_typed_data($orderIntent, $chainId, $verifyingContractAddress);
        }
    }

    public function create_order_intent_typed_data($orderIntent, $chainId, $verifyingContractAddress) {
        return array(
            'primaryType' => 'OrderParams',
            'types' => array(
                'EIP712Domain' => array(
                    array( 'name' => 'name', 'type' => 'string' ),
                    array( 'name' => 'version', 'type' => 'string' ),
                    array( 'name' => 'chainId', 'type' => 'uint256' ),
                    array( 'name' => 'verifyingContract', 'type' => 'address' ),
                ),
                'OrderParams' => array(
                    array( 'name' => 'symbol', 'type' => 'bytes32' ),
                    array( 'name' => 'strategy', 'type' => 'bytes32' ),
                    array( 'name' => 'side', 'type' => 'uint256' ),
                    array( 'name' => 'orderType', 'type' => 'uint256' ),
                    array( 'name' => 'nonce', 'type' => 'bytes32' ),
                    array( 'name' => 'amount', 'type' => 'uint256' ),
                    array( 'name' => 'price', 'type' => 'uint256' ),
                    array( 'name' => 'stopPrice', 'type' => 'uint256' ),
                ),
            ),
            'domain' => $this->create_eip712_domain_seperator($chainId, $verifyingContractAddress),
            'message' => array(
                'symbol' => $this->encode_string_into_bytes32($orderIntent->symbol),
                'strategy' => $this->encode_string_into_bytes32($orderIntent->strategy),
                'side' => $this->order_side_to_int(string) ($orderIntent->side),
                'orderType' => $this->order_type_to_int(string) ($orderIntent->orderType),
                'nonce' => $orderIntent->nonce,
                'amount' => (string) $orderIntent->amount,
                'price' => (string) $orderIntent->price,
                'stopPrice' => (string) $orderIntent->stopPrice,
            ),
        );
    }

    public function cancel_order_intent_typed_data($cancelIntent, $chainId, $verifyingContractAddress) {
        return array(
            'primaryType' => 'CancelOrderParams',
            'types' => array(
                'EIP712Domain' => array(
                    array( 'name' => 'name', 'type' => 'string' ),
                    array( 'name' => 'version', 'type' => 'string' ),
                    array( 'name' => 'chainId', 'type' => 'uint256' ),
                    array( 'name' => 'verifyingContract', 'type' => 'address' ),
                ),
                'CancelOrderParams' => array(
                    array( 'name' => 'symbol', 'type' => 'bytes32' ),
                    array( 'name' => 'orderHash', 'type' => 'bytes32' ),
                    array( 'name' => 'nonce', 'type' => 'bytes32' ),
                ),
            ),
            'domain' => $this->create_eip712_domain_seperator($chainId, $verifyingContractAddress),
            'message' => array(
                'symbol' => $this->encode_string_into_bytes32($cancelIntent->symbol),
                'orderHash' => $cancelIntent->orderHash,
                'nonce' => $cancelIntent->nonce,
            ),
        );
    }

    public function cancel_all_orders_intent_typed_data($cancelAllIntent, $chainId, $verifyingContractAddress) {
        return array(
            'primaryType' => 'CancelAllParams',
            'types' => array(
                'EIP712Domain' => array(
                    array( 'name' => 'name', 'type' => 'string' ),
                    array( 'name' => 'version', 'type' => 'string' ),
                    array( 'name' => 'chainId', 'type' => 'uint256' ),
                    array( 'name' => 'verifyingContract', 'type' => 'address' ),
                ),
                'CancelAllParams' => array(
                    array( 'name' => 'strategy', 'type' => 'bytes32' ),
                    array( 'name' => 'nonce', 'type' => 'bytes32' ),
                ),
            ),
            'domain' => $this->create_eip712_domain_seperator($chainId, $verifyingContractAddress),
            'message' => array(
                'strategy' => $this->encode_string_into_bytes32($cancelAllIntent->strategyId),
                'nonce' => $cancelAllIntent->nonce,
            ),
        );
    }

    public function profile_update_intent_typed_data($updateProfileIntent, $chainId, $verifyingContractAddress) {
        return array(
            'primaryType' => 'UpdateProfileParams',
            'types' => array(
                'EIP712Domain' => array(
                    array( 'name' => 'name', 'type' => 'string' ),
                    array( 'name' => 'version', 'type' => 'string' ),
                    array( 'name' => 'chainId', 'type' => 'uint256' ),
                    array( 'name' => 'verifyingContract', 'type' => 'address' ),
                ),
                'UpdateProfileParams' => array(
                    array( 'name' => 'payFeesInDdx', 'type' => 'bool' ),
                    array( 'name' => 'nonce', 'type' => 'bytes32' ),
                ),
            ),
            'domain' => $this->create_eip712_domain_seperator($chainId, $verifyingContractAddress),
            'message' => array(
                'payFeesInDdx' => $updateProfileIntent->payFeesInDdx,
                'nonce' => $updateProfileIntent->nonce,
            ),
        );
    }

    public function create_eip712_domain_seperator($chainId, $verifyingContractAddress) {
        return array(
            'name' => 'DerivaDEX',
            'version' => '1',
            'chainId' => $chainId,
            'verifyingContract' => $verifyingContractAddress,
        );
    }

    public function encrypt_intent($encryptionKey, $payload) {
        // Create an ephemeral ECDSA private key to encrypt the request.
        $secretKeyBytes = $this->word_array_to_bytes(CryptoJS.lib.WordArray.random (32), 32);
        // Unique single-use nonce for each encryption.
        $nonceBytes = $this->word_array_to_bytes(CryptoJS.lib.WordArray.random (12), 12);
        $json = json_encode ($payload);
        $buffer = Buffer.from ($json);
        $requestBytes = new Uint8Array ($buffer);
        $encryptionKeyBuffer = Buffer.from (mb_substr($encryptionKey, 3), 'hex');
        $encryptionKeyBytes = new Uint8Array ($encryptionKeyBuffer);
        $encryptedBytes = $this->encrypt($requestBytes, $secretKeyBytes, $encryptionKeyBytes, $nonceBytes);
        return $this->hexlify($encryptedBytes);
    }

    public function hexlify($bytes) {
        $hexCharacters = '0123456789abcdef';
        $result = '0x';
        for ($i = 0; $i < count($bytes); $i++) {
            $v = $bytes[$i];
            // eslint-disable-next-line no-bitwise
            $result .= $hexCharacters[($v & 0xf0) >> 4] . $hexCharacters[$v & 0x0f];
        }
        return $result;
    }

    public function word_array_to_bytes($wordArray, $size) {
        $bytes = new Uint8Array ($size);
        $truncatedWords = mb_substr($wordArray->words, 0, $size / 4 - 0);
        for ($i = 0; $i < $size; $i++) {
            // eslint-disable-next-line no-bitwise
            $byte = ($truncatedWords[$i >>> 2] >>> (24 - (fmod($i, 4)) * 8)) & 0xff;
            $bytes[$i] = $byte;
        }
        return $bytes;
    }

    public function encrypt($str, $secretKey, $encryptionKeyBytes, $nonceBytes) {
        $EC = elliptic.ec;
        // Create a $secp256k1 curve object
        $secp256k1 = new $EC ('secp256k1');
        // Uint8Array-encoded network public key
        $networkPublicKey = $secp256k1->keyFromPublic ($encryptionKeyBytes).getPublic ();
        // Create a PrivateKey object from the secret key
        $myPrivateKey = $secp256k1->keyFromPrivate ($secretKey);
        // Get the corresponding public key
        $myPublicKey = $myPrivateKey->getPublic ();
        $compressedPublicKeyBytes = $myPublicKey->encodeCompressed ();
        // Compute the shared public key
        $sharedPublicKey = $networkPublicKey->mul ($myPrivateKey->priv);
        $keccak256 = CryptoJS.algo.SHA3.create (array( 'outputLength' => 256 ));
        $sharedPublicKeyCompressed = $sharedPublicKey->encodeCompressed ();
        $sharedPublicKeyCompressedBytes = new Uint8Array ($sharedPublicKeyCompressed);
        $keccak256->update (CryptoJS.lib.WordArray.create ($sharedPublicKeyCompressedBytes));
        $hash = $keccak256->finalize ();
        $derivedKey = $this->word_array_to_bytes($hash, 16);
        // the provided CryptoJS static dependency does not include aes gcm encryption mode
        // so we have to use the node crypto library for now
        $cipher = $this->create_cipheriv('aes-128-gcm', $derivedKey, $nonceBytes);
        $encodedMessage = Buffer.from ($str, 'utf8');
        $messageLength = Buffer.alloc (4);
        $messageLength->writeUInt32BE (strlen($encodedMessage), 0);
        $dataToEncrypt = Buffer.concat (array( $messageLength, $encodedMessage ));
        $cipherText = $cipher->update ($dataToEncrypt, 'utf8', 'base64');
        $cipherText .= $cipher->final ('base64');
        $authTag = $cipher->getAuthTag ().toString ('base64');
        $cipherBytes = new Uint8Array (Buffer.from ($cipherText, 'base64'));
        $tagBytes = new Uint8Array (Buffer.from ($authTag, 'base64'));
        $totalLength = strlen($cipherBytes) . strlen($tagBytes) . strlen($nonceBytes) . count($compressedPublicKeyBytes);
        $concatenatedUint8Array = new Uint8Array ($totalLength);
        $offset = 0;
        $concatenatedUint8Array->set ($cipherBytes, $offset);
        $offset .= count($cipherBytes);
        $concatenatedUint8Array->set ($tagBytes, $offset);
        $offset .= count($tagBytes);
        $concatenatedUint8Array->set ($nonceBytes, $offset);
        $offset .= count($nonceBytes);
        $concatenatedUint8Array->set ($compressedPublicKeyBytes, $offset);
        return $concatenatedUint8Array;
    }

    public function fetch_balance($params = array ()) {
        return Async\async(function () use ($params) {
            /**
             * query for balance and get the amount of funds available for trading or funds locked in orders
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @return {array} a ~@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure balance structure~
             */
            $strategyRequest = array(
                'trader' => $this->walletAddress,
                'strategyId' => 'main',
            );
            $strategyResponse = Async\await($this->publicGetAccountTraderStrategyStrategyId ($strategyRequest));
            // {
            //     value => array(
            //       trader => '0x0006cef8e666768cc40cc78cf93d9611019ddcb628',
            //       strategyId => 'main',
            //       strategyIdHash => '0x2576ebd1',
            //       maxLeverage => '3',
            //       freeCollateral => '9958.802449',
            //       frozenCollateral => '1000000',
            //       frozen => false
            //     ),
            //     timestamp => '1677267890',
            //     success => true
            // }
            return $this->parse_balance($strategyResponse['value']);
        }) ();
    }

    public function parse_balance($strategy) {
        $result = array(
            'info' => $strategy,
        );
        $account = $this->account();
        $total = $this->safe_number($strategy, 'freeCollateral') . $this->safe_number($strategy, 'frozenCollateral');
        $account['total'] = (string) $total;
        $account['free'] = $this->safe_string($strategy, 'freeCollateral');
        $result['USDC'] = $account;
        return $this->safe_balance($result);
    }

    public function get_main_strategy_id_hash() {
        return '0x2576ebd1';
    }

    public function fetch_deposit_address($code, $params = array ()) {
        return Async\async(function () use ($code, $params) {
            /**
             * fetch the deposit address for a currency associated with this account
             * @param {string} $code unified currency $code
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @return {array} an {@link https://docs.ccxt.com/en/latest/manual.html#address-structure address structure}
             */
            $addresses = Async\await($this->rawGetSnapshotAddresses (array( 'contractDeployment' => 'beta' ))); // TODO => switch to mainnet
            if ($code !== 'USDC' && $code !== 'DDX') {
                throw new BadSymbol($this->id . ' fetchDepositAddress() does not support ' . $code);
            }
            return $addresses['addresses']['derivaDEXAddress'];
        }) ();
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetch all open positions
             * @param {[string]|null} $symbols list of unified market $symbols
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @return {[array]} a list of {@link https://docs.ccxt.com/en/latest/manual.html#position-structure position structure}
             */
            $response = Async\await($this->publicGetPositions ());
            $response['value'].forEach ((position) => array(
                position.timestamp = $response['timestamp'] * 1000;
            ));
            return $this->parse_positions($response['value'], $symbols);
        }) ();
    }

    public function parse_position($position, $market = null) {
        // array(
        //     trader => '0x004404ac8bd8f9618d27ad2f1485aa1b2cfd82482d',
        //     symbol => 'BTCPERP',
        //     strategyIdHash => '0x2576ebd1',
        //     side => '1',
        //     balance => '0.24',
        //     avgEntryPrice => '23271.101723',
        //     lastModifiedInEpoch => null
        // ),
        $id = $position['trader'] . '_' . $position['strategyIdHash'] . '_' . $position['symbol'];
        $timestamp = $this->safe_number($position, 'timestamp');
        return array(
            'info' => $position,
            'id' => $id,
            'symbol' => $this->safe_string($position, 'symbol'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'isoldated' => false,
            'hedged' => null,
            'side' => $position['side'] === '1' ? 'long' : 'short',
            'contracts' => $this->safe_number($position, 'balance'),
            'contractSize' => null,
            'entryPrice' => $this->safe_number($position, 'avgEntryPrice'),
            'markPrice' => null,
            'notional' => null,
            'leverage' => null,
            'collateral' => null,
            'initialMargin' => null,
            'initialMarginPercentage' => null,
            'maintenanceMargin' => null,
            'maintenanceMarginPercentage' => null,
            'unrealizedPnl' => null,
            'liquidationPrice' => null,
            'marginMode' => 'cross',
            'marginRatio' => null,
            'percentage' => null,
        );
    }

    public function fetch_funding_rates($symbols = null, $params = array ()) {
        return Async\async(function () use ($symbols, $params) {
            /**
             * fetch the funding rate for multiple markets
             * @param {[string]|null} $symbols list of unified market $symbols
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @return {array} a dictionary of {@link https://docs.ccxt.com/en/latest/manual.html#funding-$rates-structure funding $rates structures}, indexe by market $symbols
             */
            $response = Async\await($this->publicGetMarkets ());
            $response['value'].forEach ((rate) => array(
                rate.timestamp = $response['timestamp'] * 1000;
            ));
            $rates = $this->parse_funding_rates($response['value'], $symbols);
            return $this->filter_by_array($rates, 'symbol', $symbols);
        }) ();
    }

    public function fetch_funding_rate($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * fetch the current funding rate
             * @param {string} $symbol unified market $symbol
             * @param {array} $params extra parameters specific to the derivadex api endpoint
             * @return {array} a {@link https://docs.ccxt.com/en/latest/manual.html#funding-rate-structure funding rate structure}
             */
            $response = Async\await($this->publicGetMarkets (array( 'symbol' => $symbol )));
            $response['value'].forEach ((rate) => array(
                rate.timestamp = $response['timestamp'] * 1000;
            ));
            return $this->parse_funding_rates($response['value']);
        }) ();
    }

    public function parse_funding_rate($contract, $market = null) {
        // array("market":"ETHPERP","volume":"656.06","price":"1641.84","fundingRate":"0")
        $timestamp = $this->safe_number($contract, 'timestamp');
        $datetime = $this->iso8601($timestamp);
        return array(
            'info' => $contract,
            'symbol' => $this->safe_string($contract, 'market'),
            'markPrice' => $this->safe_number($contract, 'price'),
            'indexPrice' => null,
            'interestRate' => null,
            'estimatedSettlePrice' => null,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'fundingRate' => $this->safe_string($contract, 'fundingRate'),
            'fundingTimestamp' => $timestamp,
            'fundingDatetime' => $datetime,
            'nextFundingRate' => null,
            'nextFundingTimestamp' => null,
            'nextFundingDatetime' => null,
            'previousFundingRate' => null,
            'previousFundingTimestamp' => null,
            'previousFundingDatetime' => null,
        );
    }

    public function fetch_open_interest($symbol, $params = array ()) {
        return Async\async(function () use ($symbol, $params) {
            /**
             * Retrieves the open interest of a market
             * @param {string} $symbol Unified CCXT market $symbol
             * @param {array} $params exchange specific parameters
             * @return {array} an open interest structurearray(@link https://docs.ccxt.com/en/latest/manual.html#interest-history-structure)
            */
            $response = Async\await($this->publicGetMarkets (array( 'symbol' => $symbol )));
            $response['value'].forEach ((rate) => array(
                rate.timestamp = $response['timestamp'] * 1000;
            ));
            return $this->parse_open_interest($response['value'][0]);
        }) ();
    }

    public function parse_open_interest($interest, $market = null) {
        // array("market":"ETHPERP","volume":"0","price":"1569.09","fundingRate":"-0.004289023570273825","openInterest":"0.02")
        $timestamp = $this->safe_number($interest, 'timestamp');
        $datetime = $this->iso8601($timestamp);
        $openInterestAmount = $this->safe_number($interest, 'openInterest');
        $price = $this->safe_number($interest, 'price');
        return array(
            'symbol' => $this->safe_string($interest, 'market'),
            'openInterestAmount' => $openInterestAmount,
            'openInterestValue' => $openInterestAmount * $price,
            'timestamp' => $timestamp,
            'datetime' => $datetime,
            'info' => $interest,
        );
    }

    public function sign($path, $api = 'stats', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $implodedPath = $this->implode_params($path, $params);
        $query = (($api === 'v2' || $api === 'raw') ? '' : '/api/') . (($api === 'v2' || $api === 'raw') ? '' : $this->version) . '/' . $implodedPath;
        if ($method === 'GET') {
            if ($params['orderHash'] !== null) {
                $orderHashParam = '';
                for ($i = 0; $i < count($params['orderHash']); $i++) {
                    $orderHashParam .= ($i > 0 ? '&' : '') . 'orderHash=' . $params['orderHash'][$i];
                }
                $query .= '?' . $orderHashParam;
            }
            if ($params['fillReason'] !== null) {
                $fillReasonParam = '';
                for ($i = 0; $i < count($params['fillReason']); $i++) {
                    $fillReasonParam .= ($i > 0 ? '&' : '') . 'fillReason=' . $params['fillReason'][$i];
                }
                $query .= $params['orderHash'] !== null ? '&' : '?';
                $query .= $fillReasonParam;
            }
            if ($params && $params['fillReason'] === null && $params['orderHash'] === null) {
                unset($params['orderHash']);
                unset($params['fillReason']);
                $query .= '?' . $this->urlencode($params);
            }
        } else {
            $format = $this->safe_string($params, '_format');
            if ($format !== null) {
                $query .= '?' . $this->urlencode(array( '_format' => $format ));
                $params = $this->omit($params, '_format');
            }
        }
        // TODO => SWITCH TO MAINNET URL, CLEANUP
        $testApi = '';
        if ($api === 'v2') {
            $testApi = 'v2';
        } elseif ($api === 'raw') {
            $testApi = 'raw';
        } else {
            $testApi = 'op1';
        }
        $url = $this->urls['test'][$testApi] . $query; // TODO => SWITCH TO MAINNET URL
        if ($api === 'public' || $api === 'v2') {
            $headers = array(
                'Content-Type' => 'application/json',
            );
            if ($method === 'POST') {
                $body = $params;
                $headers = array(
                    'Content-Type' => 'application/octet-stream',
                );
                return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
            }
            if ($method === 'PUT' || $method === 'DELETE') {
                if ($params) {
                    $body = $this->json($params);
                }
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }
}
